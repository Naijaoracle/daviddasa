<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>XR-NPC Ward Room Simulator</title>
  <style>
    html, body { height: 100%; margin: 0; overflow: hidden; font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica, Arial; }
    #three-root { position: fixed; inset: 0; background: #eef5ee; cursor: default; }

    .ui { position: fixed; top: 0; left: 0; right: 0; pointer-events: none; }
    .tray { position: absolute; right: 16px; top: 16px; width: 340px; background: rgba(20, 24, 20, 0.85); color: #e8f5e9; border-radius: 12px; padding: 12px; box-shadow: 0 10px 30px rgba(0,0,0,0.35); pointer-events: auto; }
    .tray h3 { margin: 0 0 8px; font-size: 18px; letter-spacing: 0.2px; }
    .btns { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
    button { appearance: none; border: 0; border-radius: 10px; padding: 10px 12px; background: #2e7d32; color: white; cursor: pointer; font-weight: 600; }
    button.secondary { background: #1565c0; }
    button.warn { background: #b71c1c; }
    button.ghost { background: rgba(255,255,255,0.08); }
    button:active { transform: translateY(1px); }
    .log { margin-top: 8px; background: rgba(255,255,255,0.06); padding: 8px; border-radius: 8px; height: 96px; overflow: auto; font-size: 12px; white-space: pre-wrap; }

    .crosshair { position: fixed; left: 50%; top: 50%; width: 12px; height: 12px; margin-left: -6px; margin-top: -6px; border-radius: 50%; background: rgba(255,255,255,0.9); box-shadow: 0 0 8px rgba(255,255,255,0.5); opacity: 0.85; pointer-events: none; display: none; }
    .hint { position: fixed; left: 50%; bottom: 18px; transform: translateX(-50%); color: #cfe9cf; background: rgba(0,0,0,0.5); padding: 6px 10px; border-radius: 8px; font-size: 12px; pointer-events: none; }

    .label { color: #fff; background: rgba(0,0,0,0.65); padding: 2px 6px; border-radius: 6px; font-size: 12px; border: 1px solid rgba(255,255,255,0.2); }
    .menu-card { background: rgba(31, 41, 31, 0.95); color: #e8f5e9; border: 1px solid rgba(255,255,255,0.15); border-radius: 10px; padding: 8px; min-width: 240px; max-width: 300px; box-shadow: 0 6px 18px rgba(0,0,0,0.35); }
    .menu-card h4 { margin: 0 0 6px 0; font-size: 13px; letter-spacing: 0.2px; opacity: 0.9; }
    .menu-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 6px; }
    .menu-section { background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.08); border-radius: 8px; padding: 6px; }
    .menu-section b { font-size: 12px; opacity: 0.9; }
    .menu-section button { width: 100%; margin-top: 4px; padding: 6px 8px; font-size: 12px; border-radius: 8px; background: rgba(255,255,255,0.09); }
    .menu-section button.selected { outline: 2px solid #9ccc65; }
    .applied { background: rgba(0,0,0,0.75); padding: 4px 6px; border-radius: 8px; border: 1px solid rgba(255,255,255,0.2); font-size: 12px; }
    .chips { display:flex; flex-wrap:wrap; gap:6px; margin-top:6px; }
    .chip { background: rgba(255,255,255,0.08); border:1px solid rgba(255,255,255,0.15); border-radius:999px; padding:2px 8px; font-size:12px; }
    .applied-list { max-height:72px; overflow:auto; font-size:12px; background: rgba(255,255,255,0.06); border:1px solid rgba(255,255,255,0.1); border-radius:8px; padding:6px; margin-top:6px; }
    .kit-title { margin-top:10px; font-size:12px; opacity:0.9; }

    #startOverlay { position: fixed; inset: 0; display: flex; align-items: center; justify-content: center; background: rgba(0,0,0,0.65); color: #e8f5e9; z-index: 30; }
    #startCard { background: rgba(20,24,20,0.9); padding: 18px 20px; border-radius: 12px; box-shadow: 0 10px 30px rgba(0,0,0,0.35); text-align: center; width: 340px; }
    #startBtn { margin-top: 10px; width: 100%; }

    .vitals { color:#e8f5e9; background: rgba(0,0,0,0.75); border:1px solid rgba(255,255,255,0.2); border-radius:10px; padding:8px 10px; font-size:12px; min-width:180px; }
    .vitals .title { font-weight:700; font-size:13px; margin-bottom:4px; }
    .vitals .row { display:flex; justify-content:space-between; gap:8px; }
    .vitals .row + .row { margin-top:2px; }

    #keyHUD { position: fixed; left: 10px; bottom: 10px; background: rgba(0,0,0,0.55); color: #cfe9cf; padding: 6px 8px; border-radius: 8px; font-size: 11px; pointer-events: none; z-index: 5; }

    #joysticks { position: fixed; inset: 0; z-index: 6; display: none; pointer-events: none; }
    .joy { position: absolute; width: 120px; height: 120px; border-radius: 60px; background: rgba(255,255,255,0.35); border: 1px solid rgba(0,0,0,0.15); box-shadow: 0 8px 30px rgba(0,0,0,0.12); pointer-events: auto; }
    #joyL { left: 16px; bottom: 16px; }
    #joyR { right: 16px; bottom: 16px; }
    .knob { position: absolute; width: 56px; height: 56px; border-radius: 28px; left: 50%; top: 50%; transform: translate(-50%,-50%); background: rgba(255,255,255,0.95); border: 1px solid rgba(0,0,0,0.12); box-shadow: 0 6px 20px rgba(0,0,0,0.15); pointer-events: none; }
    .touch-hint { position: fixed; left: 50%; transform: translateX(-50%); bottom: 140px; background: rgba(255,255,255,0.85); border:1px solid rgba(0,0,0,0.1); border-radius: 10px; padding: 6px 10px; font-size: 12px; z-index: 6; display: none; color: #0b1114; text-align: center; }

    .nav-buttons { position: fixed; left: 12px; top: 12px; display: flex; gap: 8px; z-index: 100; }
    .home-button, .scoring-link, .cv-link { height: 44px; background: #ffffff; border: 2px solid #2ecc71; border-radius: 22px; display: flex; align-items: center; justify-content: center; cursor: pointer; text-decoration: none; transition: all 0.2s ease; box-shadow: 0 3px 12px rgba(0,0,0,0.3); }
    .home-button { width: 44px; }
    .scoring-link, .cv-link { font-size: 12px; font-weight: 600; color: #2ecc71; padding: 0 14px; white-space: nowrap; display: flex; align-items: center; }
    .home-button:hover, .scoring-link:hover, .cv-link:hover { background: #2ecc71; transform: translateY(-1px); box-shadow: 0 5px 16px rgba(46,204,113,0.4); }
    .home-button:hover svg { fill: white; }
    .scoring-link svg, .cv-link svg { width: 18px; height: 18px; fill: #2ecc71; margin-right: 6px; }
    .scoring-link:hover svg, .cv-link:hover svg { fill: white; }
    .scoring-link:hover, .cv-link:hover { color: white; background: #2ecc71; }
    .home-button svg { width: 20px; height: 20px; fill: #2ecc71; }

    @media (max-width: 768px) {
      .tray { width: 280px; right: 8px; top: 60px; padding: 10px; }
      .tray h3 { font-size: 16px; }
      .btns { grid-template-columns: 1fr; }
      button { font-size: 13px; padding: 8px 10px; }
      .log { font-size: 11px; height: 80px; }
      .hint { font-size: 11px; bottom: 12px; }
    }
    @media (max-width: 480px) {
      .tray { width: calc(100vw - 16px); max-width: 280px; }
      button { font-size: 12px; padding: 8px; }
      .navigation-buttons { gap: 6px; left: 8px; top: 8px; }
      .scoring-link, .cv-link { padding: 0 10px; font-size: 11px; }
    }
  </style>
</head>
<body>
  <div class="nav-buttons">
    <a href="/" class="home-button" aria-label="Home" title="Return to homepage">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
        <path d="M3 12l2-2m0 0l7-7 7 7M5 10v10a1 1 0 001 1h3m10-11l2 2m-2-2v10a1 1 0 01-1 1h-3m-6 0a1 1 0 001-1v-4a1 1 0 011-1h2a1 1 0 011 1v4a1 1 0 001 1m-6 0h6"/>
      </svg>
    </a>
    <a href="/xr-npc-dasex-evaluator.html" class="scoring-link" aria-label="Scoring System" title="Open DASEX Checklist Evaluator">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
        <polyline points="14 2 14 8 20 8"></polyline>
        <line x1="16" y1="13" x2="8" y2="13"></line>
        <line x1="16" y1="17" x2="8" y2="17"></line>
        <polyline points="10 9 9 9 8 9"></polyline>
      </svg>
      Scoring System
    </a>
    <a href="/daviddasaCV.html" class="cv-link" aria-label="Interactive CV" title="View Interactive CV">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <path d="M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2"></path>
        <circle cx="9" cy="7" r="4"></circle>
        <path d="M22 21v-2a4 4 0 0 0-3-3.87"></path>
        <path d="M16 3.13a4 4 0 0 1 0 7.75"></path>
      </svg>
      Interactive CV
    </a>
  </div>
  <div id="three-root"></div>

  <div id="startOverlay">
    <div id="startCard">
      <div style="font-weight:700; font-size:18px; margin-bottom:6px;">Click to start</div>
      <div id="startInfo" style="font-size:13px; opacity:0.9;">WASD moves camera. Arrows move nurse. Click and drag to look.</div>
      <button id="startBtn">Start demo</button>
    </div>
  </div>

  <div class="ui">
    <div class="tray" id="tray">
      <h3>Session <span id="status" style="font-size:12px;opacity:0.85"></span></h3>
      <div class="log" id="log">Use the red trolley to pick kit. Walk to the patient to apply.</div>
      <div style="display:flex; gap:8px; margin-top:8px;">
        <button class="warn" id="recordBtn">Record</button>
        <a id="downloadBtn" class="secondary" style="display:none; text-decoration:none; text-align:center; line-height:32px; padding: 0 12px; border-radius:10px; background:#1565c0; color:white;">Download log</a>
      </div>
    </div>
  </div>
  <div class="crosshair" id="crosshair" title="aim"></div>
  <div class="hint" id="hint">WASD moves camera. Arrows move nurse. Click and drag to look.</div>
  <div id="keyHUD">I:0 J:0 K:0 L:0 U:0 O:0</div>
  <div id="joysticks">
    <div class="joy" id="joyL"><div class="knob" id="knobL"></div></div>
    <div class="joy" id="joyR"><div class="knob" id="knobR"></div></div>
  </div>
  <div class="touch-hint" id="touchHint">Move left, look right</div>

  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js"
      }
    }
  </script>
  <script type="module">
    import * as THREE from 'three';
    import { CSS2DRenderer, CSS2DObject } from 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/renderers/CSS2DRenderer.js';

    const statusEl = document.getElementById('status');
    const hintEl = document.getElementById('hint');
    const startOverlay = document.getElementById('startOverlay');
    const startBtn = document.getElementById('startBtn');
    const keyHUD = document.getElementById('keyHUD');
    function updateKeyHUD(){ if(!keyHUD) return; keyHUD.textContent = `I:${nkey.i?1:0} J:${nkey.j?1:0} K:${nkey.k?1:0} L:${nkey.l?1:0} U:${nkey.u?1:0} O:${nkey.o?1:0}`; }

    function setStatus(text, color = '#9ccc65') { statusEl.textContent = `• ${text}`; statusEl.style.color = color; }
    try { console.assert(!!THREE && !!THREE.Scene, 'THREE failed to load'); setStatus('Modules OK'); } catch (e) { setStatus('Module load error', '#ff8a80'); console.error(e); }

    const root = document.getElementById('three-root');
    root.setAttribute('tabindex','-1');

    // Scene and camera
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xf2f8f2);
    const rig = new THREE.Object3D();
    const pitch = new THREE.Object3D();
    const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 200);
    rig.add(pitch); pitch.add(camera);
    rig.position.set(0, 0, 3.5);
    pitch.position.set(0, 1.6, 0);
    scene.add(rig);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(window.innerWidth, window.innerHeight);
    root.appendChild(renderer.domElement);
    renderer.domElement.setAttribute('tabindex','-1');

    // CSS2D overlay
    const labelRenderer = new CSS2DRenderer();
    labelRenderer.setSize(window.innerWidth, window.innerHeight);
    labelRenderer.domElement.style.position = 'fixed';
    labelRenderer.domElement.style.inset = '0';
    labelRenderer.domElement.style.pointerEvents = 'none';
    root.appendChild(labelRenderer.domElement);
    labelRenderer.domElement.setAttribute('tabindex','-1');

    // Lights
    const hemi = new THREE.HemisphereLight(0xffffff, 0xdedede, 1.4); scene.add(hemi);
    const amb = new THREE.AmbientLight(0xffffff, 0.4); scene.add(amb);
    const dir = new THREE.DirectionalLight(0xffffff, 1.2); dir.position.set(4, 8, 2); scene.add(dir);

    // Room
    const ROOM = 10; const HALF = ROOM / 2; const room = new THREE.Group(); scene.add(room);
    const wallMat = new THREE.MeshStandardMaterial({ color: 0xe6efe6, metalness: 0, roughness: 0.9 });
    const floorMat = new THREE.MeshStandardMaterial({ color: 0xf2f7f2, roughness: 0.95 });
    const trimMat  = new THREE.MeshStandardMaterial({ color: 0xbf4a4a, roughness: 1 });

    const floor = new THREE.Mesh(new THREE.BoxGeometry(ROOM, 0.1, ROOM), floorMat); floor.position.set(0, -0.05, 0); floor.receiveShadow = true; room.add(floor);
    const ceiling = new THREE.Mesh(new THREE.BoxGeometry(ROOM, 0.1, ROOM), new THREE.MeshStandardMaterial({ color: 0xdfe7df })); ceiling.position.set(0, 3, 0); room.add(ceiling);

    const makeWall = (w, h, d, x, y, z) => { const m = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), wallMat); m.position.set(x, y, z); m.receiveShadow = true; return m; };
    room.add(makeWall(ROOM, 3, 0.2,  0, 1.5, -HALF));
    room.add(makeWall(ROOM, 3, 0.2,  0, 1.5,  HALF));
    room.add(makeWall(0.2, 3, ROOM, -HALF, 1.5, 0));
    room.add(makeWall(0.2, 3, ROOM,  HALF, 1.5, 0));

    const bandLen = ROOM - 0.05;
    const band = new THREE.Mesh(new THREE.BoxGeometry(bandLen, 0.2, 0.1), trimMat); band.position.set(0, 0.8, -HALF + 0.05); room.add(band.clone());
    const band2 = band.clone(); band2.position.set(0, 0.8, HALF - 0.05); room.add(band2);
    const band3 = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.2, bandLen), trimMat); band3.position.set(-HALF + 0.05, 0.8, 0); room.add(band3.clone());
    const band4 = band3.clone(); band4.position.set(HALF - 0.05, 0.8, 0); room.add(band4);

    // Resus trolley - drawers, handles, frame, wheels, labels
    function makeResusTrolley(){
      const g = new THREE.Group();

      const red = new THREE.MeshStandardMaterial({ color: 0xc62828, roughness: 0.9 });
      const grey = new THREE.MeshStandardMaterial({ color: 0xb0b4b7, metalness: 0.3, roughness: 0.5 });
      const dark = new THREE.MeshStandardMaterial({ color: 0x1c1c1c, roughness: 0.8 });

      const W = 0.9, D = 0.6, H = 1.05;
      const bodyW = 0.74, bodyD = 0.5, bodyH = 0.82;

      // Outer posts
      const postGeo = new THREE.BoxGeometry(0.08, H, 0.08);
      const posts = [
        [-W/2, H/2, -D/2],
        [ W/2, H/2, -D/2],
        [-W/2, H/2,  D/2],
        [ W/2, H/2,  D/2]
      ];
      posts.forEach(p=>{ const m = new THREE.Mesh(postGeo, grey); m.position.set(p[0], p[1], p[2]); g.add(m); });

      // Top work surface with rails
      const top = new THREE.Mesh(new THREE.BoxGeometry(W-0.1, 0.05, D-0.1), grey);
      top.position.set(0, H-0.02, 0); g.add(top);
      const railGeo = new THREE.CylinderGeometry(0.025, 0.025, W-0.18, 14);
      const railF = new THREE.Mesh(railGeo, grey); railF.rotation.z = Math.PI/2; railF.position.set(0, H+0.08, D/2 - 0.1);
      const railB = railF.clone(); railB.position.z = -D/2 + 0.1;
      const railL = new THREE.Mesh(new THREE.CylinderGeometry(0.025, 0.025, D-0.18, 14), grey); railL.position.set(-W/2 + 0.1, H+0.08, 0);
      const railR = railL.clone(); railR.position.x = W/2 - 0.1;
      railL.rotation.x = railR.rotation.x = Math.PI/2;
      g.add(railF, railB, railL, railR);

      // Push handle on right side
      const handle = new THREE.Mesh(new THREE.CylinderGeometry(0.03, 0.03, 0.6, 12), grey);
      handle.rotation.z = Math.PI/2;
      handle.position.set(W/2 + 0.07, H-0.15, 0);
      g.add(handle);

      // Cabinet body
      const body = new THREE.Mesh(new THREE.BoxGeometry(bodyW, bodyH, bodyD), red);
      body.position.set(0, 0.26 + bodyH/2, 0);
      g.add(body);

      // Drawers with handles
      const drawCount = 5;
      const gap = 0.01;
      const usableH = bodyH - 0.06;
      const drawH = usableH / drawCount - gap;
      const frontDepth = 0.02;

      const handleMat = new THREE.MeshStandardMaterial({ color: 0xd7d9db, metalness: 0.7, roughness: 0.3 });

      const labelStyle = 'padding:2px 4px;background:#fff;color:#111;border-radius:3px;border:1px solid rgba(0,0,0,0.25);font-size:10px;letter-spacing:0.3px;';
      const labelTexts = ['AIRWAY','BREATHING','CIRCULATION','I.V. FLUIDS'];
      let labelIndex = 0;

      for(let i=0;i<drawCount;i++){
        const y = body.position.y - bodyH/2 + 0.03 + i*(drawH+gap) + drawH/2;
        const front = new THREE.Mesh(new THREE.BoxGeometry(bodyW+0.02, drawH, frontDepth), red);
        front.position.set(0, y, bodyD/2 + frontDepth/2);
        g.add(front);

        // Handle bar
        const handleBar = new THREE.Mesh(new THREE.CylinderGeometry(0.015, 0.015, bodyW*0.45, 16), handleMat);
        handleBar.rotation.z = Math.PI/2;
        handleBar.position.set(0, y, bodyD/2 + frontDepth + 0.03);
        g.add(handleBar);

        // Drawer labels as CSS2D
        const div = document.createElement('div');
        div.style.cssText = labelStyle;
        if (i === 0) {
          div.textContent = 'CARDIAC';
          const div2 = document.createElement('div');
          div2.style.cssText = labelStyle;
          div2.textContent = 'ANAPHYLAXIS';
          const l1 = new CSS2DObject(div);   l1.position.set(-bodyW*0.32, y, bodyD/2 + frontDepth + 0.001);
          const l2 = new CSS2DObject(div2);  l2.position.set( bodyW*0.28, y, bodyD/2 + frontDepth + 0.001);
          g.add(l1, l2);
        } else {
          div.textContent = labelTexts[labelIndex++] || 'SUPPLIES';
          const lab = new CSS2DObject(div);
          lab.position.set(-bodyW*0.34, y, bodyD/2 + frontDepth + 0.001);
          g.add(lab);
        }
      }

      // Wheels and casters
      for(let i=0;i<4;i++){
        const wx = i%2===0 ? -W/2 + 0.12 : W/2 - 0.12;
        const wz = i<2 ? -D/2 + 0.12 : D/2 - 0.12;
        const wheel = new THREE.Mesh(new THREE.CylinderGeometry(0.07, 0.07, 0.04, 20), dark);
        wheel.rotation.x = Math.PI/2;
        wheel.position.set(wx, 0.12, wz);
        const caster = new THREE.Mesh(new THREE.CylinderGeometry(0.02, 0.02, 0.1, 12), grey);
        caster.position.set(wx, 0.18, wz);
        g.add(wheel, caster);
      }

      return g;
    }

    const trolley = makeResusTrolley();
    trolley.position.set(3.0, 0, 1.6);
    room.add(trolley);

    // Nurse with visible head and simple walk animation
    function buildNurse(colorMain = 0x1b5e20, colorCap = 0x2067d4){
      const group = new THREE.Group();
      const skin = 0xf0c8a0;
      const shoes = 0x252525;
      const accent = 0x2e7d32;

      const torso = new THREE.Mesh(new THREE.CapsuleGeometry(0.24, 0.5, 12, 20), new THREE.MeshStandardMaterial({ color: colorMain, roughness: 0.95 }));
      torso.position.y = 1.05;

      const neck = new THREE.Mesh(new THREE.CylinderGeometry(0.09, 0.09, 0.10, 16), new THREE.MeshStandardMaterial({ color: skin, roughness: 0.8 }));
      neck.position.y = 1.33;

      const head = new THREE.Mesh(new THREE.SphereGeometry(0.19, 28, 18), new THREE.MeshStandardMaterial({ color: skin, roughness: 0.7 }));
      head.position.y = 1.56;

      const cap = new THREE.Mesh(new THREE.SphereGeometry(0.21, 24, 16), new THREE.MeshStandardMaterial({ color: colorCap, roughness: 0.95 }));
      cap.scale.set(1.0, 0.55, 1.0);
      cap.position.y = 1.66;

      const eyeGeo = new THREE.SphereGeometry(0.012, 8, 8);
      const eyeMat = new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.9 });
      const eyeL = new THREE.Mesh(eyeGeo, eyeMat); eyeL.position.set(-0.05, 1.56, 0.16);
      const eyeR = new THREE.Mesh(eyeGeo, eyeMat); eyeR.position.set( 0.05, 1.56, 0.16);

      const shoulderL = new THREE.Object3D(); shoulderL.position.set(-0.34, 1.22, 0);
      const shoulderR = new THREE.Object3D(); shoulderR.position.set( 0.34, 1.22, 0);
      const armGeo = new THREE.CapsuleGeometry(0.075, 0.34, 12, 20);
      const armMat = new THREE.MeshStandardMaterial({ color: colorMain, roughness: 0.95 });
      const armL = new THREE.Mesh(armGeo, armMat); armL.position.y = -0.22;
      const armR = new THREE.Mesh(armGeo, armMat); armR.position.y = -0.22;
      shoulderL.add(armL); shoulderR.add(armR);

      const handGeo = new THREE.SphereGeometry(0.065, 16, 12);
      const handMat = new THREE.MeshStandardMaterial({ color: skin, roughness: 0.8 });
      const handL = new THREE.Mesh(handGeo, handMat); handL.position.set(0, -0.46, 0.02); shoulderL.add(handL);
      const handR = new THREE.Mesh(handGeo, handMat); handR.position.set(0, -0.46,-0.02); shoulderR.add(handR);

      const hipL = new THREE.Object3D(); hipL.position.set(-0.12, 0.90, 0);
      const hipR = new THREE.Object3D(); hipR.position.set( 0.12, 0.90, 0);
      const legGeo = new THREE.CapsuleGeometry(0.095, 0.46, 12, 20);
      const legMat = new THREE.MeshStandardMaterial({ color: colorMain, roughness: 0.95 });
      const legL = new THREE.Mesh(legGeo, legMat); legL.position.y = -0.33; hipL.add(legL);
      const legR = new THREE.Mesh(legGeo, legMat); legR.position.y = -0.33; hipR.add(legR);

      const shoeGeo = new THREE.CapsuleGeometry(0.09, 0.06, 10, 18);
      const shoeMat = new THREE.MeshStandardMaterial({ color: shoes, roughness: 0.9 });
      const shoeL = new THREE.Mesh(shoeGeo, shoeMat); shoeL.rotation.x = Math.PI*0.5; shoeL.position.set(0, -0.60, 0.06); hipL.add(shoeL);
      const shoeR = new THREE.Mesh(shoeGeo, shoeMat); shoeR.rotation.x = Math.PI*0.5; shoeR.position.set(0, -0.60, 0.06); hipR.add(shoeR);

      const badge = new THREE.Mesh(new THREE.BoxGeometry(0.06, 0.08, 0.005), new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.9 }));
      badge.position.set(0.13, 1.18, 0.23);

      group.add(torso, neck, head, cap, eyeL, eyeR, shoulderL, shoulderR, hipL, hipR, badge);
      group.userData.limbs = { shoulderL, shoulderR, hipL, hipR, head, torso };
      group.userData.cap = cap;
      return group;
    }

    // Nurse avatar
    const avatar = buildNurse(0x1b5e20); scene.add(avatar);
    avatar.position.set(-0.6, 0, -3.5);
    avatar.lookAt(-2.2, 0, -2.2);

    const nurseLabelDiv = document.createElement('div');
    nurseLabelDiv.className = 'label';
    nurseLabelDiv.textContent = 'Nurse Sarah';
    const nurseNameLabel = new CSS2DObject(nurseLabelDiv);
    nurseNameLabel.position.set(0, 1.9, 0);
    avatar.add(nurseNameLabel);

    const kitCountDiv = document.createElement('div');
    kitCountDiv.className = 'label';
    kitCountDiv.textContent = 'Kit: 0';
    const kitCountLabel = new CSS2DObject(kitCountDiv);
    kitCountLabel.position.set(0, 2.1, 0);
    avatar.add(kitCountLabel);

    // Doctor NPC - static blocker facing the patient
    const doctor = buildNurse(0x26418f, 0x2067d4); // blue base, blue cap
    scene.add(doctor);
    doctor.position.set(-2.6, 0, -0.6); // farther from bed
    if (doctor.userData.cap) doctor.userData.cap.material.color.set(0x2067d4);
    doctor.rotation.y = 0;
    const doctorNameDiv = document.createElement('div');
    doctorNameDiv.className = 'label';
    doctorNameDiv.textContent = 'Dr James';
    const doctorName = new CSS2DObject(doctorNameDiv);
    doctorName.position.set(0, 1.9, 0);
    doctor.add(doctorName);

    // Bed + patient
    function makePatientBed(x, z) {
      const g = new THREE.Group();
      const frameMat = new THREE.MeshStandardMaterial({ color: 0x707b7c, roughness: 0.8 });
      const base = new THREE.Mesh(new THREE.BoxGeometry(2.2, 0.2, 0.9), frameMat); base.position.set(0, 0.5, 0); g.add(base);
      const legGeom = new THREE.BoxGeometry(0.12, 0.5, 0.12);
      const leg1 = new THREE.Mesh(legGeom, frameMat); leg1.position.set(-1.0, 0.25, -0.35);
      const leg2 = leg1.clone(); leg2.position.set( 1.0, 0.25, -0.35);
      const leg3 = leg1.clone(); leg3.position.set(-1.0, 0.25,  0.35);
      const leg4 = leg1.clone(); leg4.position.set( 1.0, 0.25,  0.35);
      g.add(leg1, leg2, leg3, leg4);
      const mattress = new THREE.Mesh(new THREE.BoxGeometry(2.1, 0.18, 0.8), new THREE.MeshStandardMaterial({ color: 0x99c1a8 })); mattress.position.set(0, 0.7, 0);
      const pillow = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.12, 0.35), new THREE.MeshStandardMaterial({ color: 0xffffff })); pillow.position.set(0.9, 0.82, 0);
      g.add(mattress, pillow);
      const rail = new THREE.Mesh(new THREE.BoxGeometry(2.15, 0.05, 0.05), frameMat); rail.position.set(0, 0.9, -0.42);
      const rail2 = rail.clone(); rail2.position.z = 0.42; g.add(rail, rail2);
      const patient = new THREE.Group();
      const gown = 0x1e88e5;
      const pBody = new THREE.Mesh(new THREE.BoxGeometry(1.1, 0.25, 0.45), new THREE.MeshStandardMaterial({ color: gown })); pBody.name = 'patientBody'; pBody.position.set(0.1, 0.86, 0);
      const pHead = new THREE.Mesh(new THREE.BoxGeometry(0.26, 0.26, 0.26), new THREE.MeshStandardMaterial({ color: 0xd1b290 })); pHead.position.set(0.95, 0.95, 0);
      const pArmL = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.12, 0.12), new THREE.MeshStandardMaterial({ color: gown })); pArmL.position.set(0.2, 0.86, -0.33);
      const pArmR = pArmL.clone(); pArmR.position.z = 0.33;
      const pLegL = new THREE.Mesh(new THREE.BoxGeometry(0.55, 0.16, 0.16), new THREE.MeshStandardMaterial({ color: gown })); pLegL.position.set(-0.35, 0.78, -0.12);
      const pLegR = pLegL.clone(); pLegR.position.z = 0.12;
      const blanket = new THREE.Mesh(new THREE.BoxGeometry(1.2, 0.06, 0.6), new THREE.MeshStandardMaterial({ color: 0x6aa7c8, transparent: true, opacity: 0.9 })); blanket.position.set(-0.15, 0.92, 0);
      patient.add(pBody, pHead, pArmL, pArmR, pLegL, pLegR, blanket); g.add(patient);
      const patientLabelDiv = document.createElement('div'); patientLabelDiv.className = 'label'; patientLabelDiv.textContent = 'Patient 001'; const patientLabel = new CSS2DObject(patientLabelDiv); patientLabel.position.set(0.95, 1.1, 0); g.add(patientLabel);
      g.position.set(x, 0, z); return g;
    }
    const bed = makePatientBed(-2.2, -2.2); scene.add(bed);

    // Collision helpers
    const bedBox = new THREE.Box3().setFromObject(bed);
    const trolleyBox = new THREE.Box3().setFromObject(trolley);
    function rectFromBox3(b) { return { minX: b.min.x, maxX: b.max.x, minZ: b.min.z, maxZ: b.max.z }; }
    const bedRect = rectFromBox3(bedBox);
    const trolleyRect = rectFromBox3(trolleyBox);
    const nurseRadius = 0.32;
    const doctorRadius = 0.34;

    function circleRectOverlap(cx, cz, r, rect) {
      const clampedX = Math.max(rect.minX, Math.min(cx, rect.maxX));
      const clampedZ = Math.max(rect.minZ, Math.min(cz, rect.maxZ));
      const dx = cx - clampedX; const dz = cz - clampedZ; return (dx*dx + dz*dz) <= r*r;
    }
    function circleCircleOverlap(cx, cz, r, ox, oz, or){
      const dx = cx - ox, dz = cz - oz;
      return (dx*dx + dz*dz) <= (r+or)*(r+or);
    }

    // Input
    let t = 0;
    let dragging = false, lastX = 0, lastY = 0; const maxPitch = Math.PI/2 - 0.05;

    function enableDragLook() {
      root.style.cursor = 'grab'; hintEl.textContent = 'Drag to look. WASD moves camera. Arrows move nurse.';
      const onDown = (e)=>{ dragging = true; lastX = e.clientX; lastY = e.clientY; root.style.cursor = 'grabbing'; };
      const onUp = ()=>{ dragging = false; root.style.cursor = 'grab'; };
      const onMove = (e)=>{ if(!dragging) return; const dx=e.clientX-lastX, dy=e.clientY-lastY; lastX=e.clientX; lastY=e.clientY; rig.rotation.y -= dx*0.0022; pitch.rotation.x = Math.max(-maxPitch, Math.min(maxPitch, pitch.rotation.x - dy*0.0022)); };
      renderer.domElement.addEventListener('mousedown', onDown); window.addEventListener('mouseup', onUp); window.addEventListener('mousemove', onMove);
    }
    startBtn.addEventListener('click', ()=>{
      startOverlay.style.display='none';
      enableDragLook();
      setStatus('Sandbox safe mode');
      try { root.focus({ preventScroll: true }); } catch {}
    });

    const nkey = { i:false, j:false, k:false, l:false, u:false, o:false };
    const key = { w:false, a:false, s:false, d:false };

    let keyboardSeen = false;
    function setKey(e, down){
      const tag = (e.target && e.target.tagName) || '';
      if (tag === 'INPUT' || tag === 'TEXTAREA' || e.isComposing) return;
      const k = (e.key || '').toLowerCase();
      const c = e.code || '';
      let handled = false;
      if (c==='KeyW' || k==='w') { key.w = down; handled = true; }
      if (c==='KeyA' || k==='a') { key.a = down; handled = true; }
      if (c==='KeyS' || k==='s') { key.s = down; handled = true; }
      if (c==='KeyD' || k==='d') { key.d = down; handled = true; }
      if (c==='KeyI' || k==='i' || c==='ArrowUp')    { nkey.i = down; handled = true; }
      if (c==='KeyJ' || k==='j' || c==='ArrowLeft')  { nkey.j = down; handled = true; }
      if (c==='KeyK' || k==='k' || c==='ArrowDown')  { nkey.k = down; handled = true; }
      if (c==='KeyL' || k==='l' || c==='ArrowRight'){ nkey.l = down; handled = true; }
      if (c==='KeyU' || k==='u')                     { nkey.u = down; handled = true; }
      if (c==='KeyO' || k==='o')                     { nkey.o = down; handled = true; }
      if (handled) { e.preventDefault(); updateKeyHUD(); if(!keyboardSeen){ keyboardSeen=true; setStatus('Modules OK • Keyboard OK'); } }
    }
    window.addEventListener('keydown', e=> setKey(e, true),  { capture: true });
    window.addEventListener('keyup',   e=> setKey(e, false), { capture: true });
    document.addEventListener('keydown', e=> setKey(e, true));
    document.addEventListener('keyup',   e=> setKey(e, false));
    document.body.addEventListener('keydown', e=> setKey(e, true));
    document.body.addEventListener('keyup',   e=> setKey(e, false));
    renderer.domElement.addEventListener('keydown', e=> setKey(e, true));
    renderer.domElement.addEventListener('keyup',   e=> setKey(e, false));
    labelRenderer.domElement.addEventListener('keydown', e=> setKey(e, true));
    labelRenderer.domElement.addEventListener('keyup',   e=> setKey(e, false));
    root.addEventListener('pointerdown', ()=>{ try { root.focus({ preventScroll: true }); } catch {} });

    // Mobile joysticks
    const isTouch = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
    let joyMove = { x: 0, y: 0 };
    let joyLook = { x: 0, y: 0 };

    if (isTouch) {
      const js = document.getElementById('joysticks');
      const l = document.getElementById('joyL');
      const r = document.getElementById('joyR');
      const kl = document.getElementById('knobL');
      const kr = document.getElementById('knobR');
      const hint = document.getElementById('touchHint');
      js.style.display = 'block';
      hint.style.display = 'block';
      setTimeout(()=>{ hint.style.display='none'; }, 4000);

      function bind(el, knob, onChange){
        let act = false, cx = 0, cy = 0;
        const max = 48;
        const reset = () => { knob.style.left='50%'; knob.style.top='50%'; onChange(0,0); };
        const pos = (x,y) => { knob.style.left=(x+cx)+'px'; knob.style.top=(y+cy)+'px'; };
        el.addEventListener('touchstart', ev=>{
          const r = el.getBoundingClientRect();
          cx = r.width/2;
          cy = r.height/2;
          act = true;
          pos(0,0);
          ev.preventDefault();
        }, {passive:false});
        el.addEventListener('touchmove', ev=>{
          if(!act) return;
          const t = ev.changedTouches[0];
          const r = el.getBoundingClientRect();
          const dx = t.clientX - (r.left + r.width/2);
          const dy = t.clientY - (r.top + r.height/2);
          const len = Math.hypot(dx,dy);
          const scl = len>max ? max/len : 1;
          const nx = dx*scl, ny = dy*scl;
          pos(nx, ny);
          onChange(nx/max, ny/max);
          ev.preventDefault();
        }, {passive:false});
        el.addEventListener('touchend', ()=>{ act=false; reset(); }, {passive:false});
        el.addEventListener('touchcancel', ()=>{ act=false; reset(); }, {passive:false});
      }

      bind(l, kl, (x,y)=>{ joyMove.x = x; joyMove.y = -y; });
      bind(r, kr, (x,y)=>{ joyLook.x = x; joyLook.y = y; });
    }

    const speed = 2.8; const bounds = { minX: -HALF + 0.5, maxX: HALF - 0.5, minZ: -HALF + 0.5, maxZ: HALF - 0.5 };

    // Nurse movement
    const nurseSpeed = 1.8; const nurseRotSpeed = 1.8; let followNurse = false;

    function moveNurse(dt) {
      const keys = nkey.i||nkey.j||nkey.k||nkey.l;
      let v = new THREE.Vector3();
      if (keys) {
        if (nkey.u) avatar.rotation.y += nurseRotSpeed * dt;
        if (nkey.o) avatar.rotation.y -= nurseRotSpeed * dt;

        const yaw = avatar.rotation.y;
        const forwardN = new THREE.Vector3(Math.sin(yaw), 0, -Math.cos(yaw));
        const rightN = new THREE.Vector3().crossVectors(forwardN, new THREE.Vector3(0,1,0));

        if (nkey.i) v.add(forwardN);
        if (nkey.k) v.sub(forwardN);
        if (nkey.j) v.sub(rightN);
        if (nkey.l) v.add(rightN);

        if (joyLook.y > 0) v.add(forwardN);
        if (joyLook.y < 0) v.sub(forwardN);
        if (joyLook.x < 0) v.sub(rightN);
        if (joyLook.x > 0) v.add(rightN);

        if (v.lengthSq() > 1e-8) v.normalize().multiplyScalar(nurseSpeed * dt);

        const tryPos = avatar.position.clone();

        // X axis
        tryPos.x += v.x;
        if (
          !circleRectOverlap(tryPos.x, avatar.position.z, nurseRadius, bedRect) &&
          !circleRectOverlap(tryPos.x, avatar.position.z, nurseRadius, trolleyRect) &&
          !circleCircleOverlap(tryPos.x, avatar.position.z, nurseRadius, doctor.position.x, doctor.position.z, doctorRadius)
        ) {
          avatar.position.x = tryPos.x;
        }

        // Z axis
        tryPos.z = avatar.position.z + v.z;
        if (
          !circleRectOverlap(avatar.position.x, tryPos.z, nurseRadius, bedRect) &&
          !circleRectOverlap(avatar.position.x, tryPos.z, nurseRadius, trolleyRect) &&
          !circleCircleOverlap(avatar.position.x, tryPos.z, nurseRadius, doctor.position.x, doctor.position.z, doctorRadius)
        ) {
          avatar.position.z = tryPos.z;
        }

        avatar.position.x = Math.max(bounds.minX+0.25, Math.min(bounds.maxX-0.25, avatar.position.x));
        avatar.position.z = Math.max(bounds.minZ+0.25, Math.min(bounds.maxZ-0.25, avatar.position.z));
      }
    }

    // Camera follow
    const upAxis = new THREE.Vector3(0,1,0);
    function updateCameraFollow() {
      const offset = new THREE.Vector3(0, 0, 2.6);
      offset.applyAxisAngle(upAxis, avatar.rotation.y);
      const target = new THREE.Vector3().copy(avatar.position).add(offset);
      rig.position.x = Math.max(bounds.minX+0.3, Math.min(bounds.maxX-0.3, target.x));
      rig.position.z = Math.max(bounds.minZ+0.3, Math.min(bounds.maxZ-0.3, target.z));
    }

    function move(dt) {
      const forward = new THREE.Vector3(Math.sin(rig.rotation.y), 0, -Math.cos(rig.rotation.y));
      const right = new THREE.Vector3().crossVectors(forward, new THREE.Vector3(0,1,0));
      const vel = new THREE.Vector3();
      if (key.w) vel.add(forward);
      if (key.s) vel.sub(forward);
      if (key.a) vel.sub(right);
      if (key.d) vel.add(right);
      if (joyMove.y > 0) vel.add(forward);
      if (joyMove.y < 0) vel.sub(forward);
      if (joyMove.x < 0) vel.sub(right);
      if (joyMove.x > 0) vel.add(right);
      if (vel.lengthSq()>0) vel.normalize().multiplyScalar(speed*dt);
      rig.position.add(vel);
      rig.position.x = Math.max(bounds.minX+0.3, Math.min(bounds.maxX-0.3, rig.position.x));
      rig.position.z = Math.max(bounds.minZ+0.3, Math.min(bounds.maxZ-0.3, rig.position.z));
    }

    // UI and recording
    const log = document.getElementById('log'); const tray = document.getElementById('tray');
    const nurseUI = document.createElement('div'); nurseUI.innerHTML = `
      <div style="margin-top:10px; font-size:12px; opacity:0.9;">Nurse control</div>
      <div class="btns" style="margin-top:6px;">
        <button id="followBtn" class="secondary">Follow nurse: Off</button>
        <button id="resetNurseBtn">Reset nurse</button>
      </div>
      <div style="font-size:11px; opacity:0.8; margin-top:6px;">Move nurse with I J K L or arrow keys. Rotate with U and O.</div>
    `; tray.appendChild(nurseUI);
    const followBtn = document.getElementById('followBtn'); const resetNurseBtn = document.getElementById('resetNurseBtn');

    const kitUI = document.createElement('div');
    kitUI.innerHTML = `
      <div class="kit-title">Kit queue</div>
      <div id="kitChips" class="chips"></div>
      <div class="kit-title">Applied history</div>
      <div id="appliedList" class="applied-list"></div>
    `;
    tray.appendChild(kitUI);
    const kitChips = document.getElementById('kitChips');
    const appliedList = document.getElementById('appliedList');

    tray.addEventListener('click', (e)=>{});

    const recordBtn = document.getElementById('recordBtn'); const downloadBtn = document.getElementById('downloadBtn'); let recording = false; let events = []; let sampleTimer = null;
    function logEvent(type, data = {}) { const entry = { t: new Date().toISOString(), type, ...data }; events.push(entry); if (type !== 'pos') { const now = new Date().toLocaleTimeString(); log.textContent = `[${now}] ${type === 'action' ? data.action : type}\n` + log.textContent; } }
    function startSampling(){ if(sampleTimer) return; sampleTimer = setInterval(()=>{ logEvent('pos', { x: rig.position.x, y: rig.position.y, z: rig.position.z, yaw: rig.rotation.y, pitch: pitch.rotation.x }); }, 300); }
    function stopSampling(){ if(sampleTimer){ clearInterval(sampleTimer); sampleTimer = null; } }
    recordBtn.addEventListener('click', ()=>{ recording = !recording; recordBtn.textContent = recording ? 'Stop' : 'Record'; recordBtn.classList.toggle('secondary', recording); if(recording){ events = []; downloadBtn.style.display='none'; logEvent('record_start'); startSampling(); } else { stopSampling(); logEvent('record_stop'); const blob = new Blob([JSON.stringify({ events }, null, 2)], { type: 'application/json' }); const url = URL.createObjectURL(blob); downloadBtn.href = url; downloadBtn.download = `session-log-${new Date().toISOString().replace(/[:.]/g, '-')}.json`; downloadBtn.style.display='inline-block'; } });
    downloadBtn.addEventListener('click', ()=>{ const href = downloadBtn.href; setTimeout(()=>URL.revokeObjectURL(href), 4000); });

    followBtn.addEventListener('click', ()=>{ followNurse = !followNurse; followBtn.textContent = `Follow nurse: ${followNurse ? 'On' : 'Off'}`; followBtn.classList.toggle('secondary', !followNurse); });
    resetNurseBtn.addEventListener('click', ()=>{ avatar.position.set(-0.6, 0, -2.1); avatar.rotation.set(0,0,0); });

    // Trolley proximity menu
    const menuDiv = document.createElement('div');
    menuDiv.className = 'menu-card';
    menuDiv.style.display = 'none';
    menuDiv.style.pointerEvents = 'auto';
    menuDiv.innerHTML = `
      <h4>Resus trolley items</h4>
      <div class="menu-grid">
        <div class="menu-section" data-section="G"><b>Adrenaline</b>
          <button data-item="Adrenaline IM 1:1000">Adrenaline IM 1:1000</button>
        </div>
        <div class="menu-section" data-section="A"><b>Airway</b>
          <button data-item="Oropharyngeal airway">Oropharyngeal airway</button>
          <button data-item="Suction catheter">Suction catheter</button>
          <button data-item="Bag valve mask">Bag valve mask</button>
        </div>
        <div class="menu-section" data-section="B"><b>Breathing</b>
          <button data-item="Oxygen mask 15 L">Oxygen mask 15 L</button>
          <button data-item="Nebuliser salbutamol">Nebuliser salbutamol</button>
        </div>
        <div class="menu-section" data-section="C"><b>Circulation</b>
          <button data-item="Non invasive BP">Non invasive BP</button>
        </div>
        <div class="menu-section" data-section="F"><b>IV / Fluids</b>
          <button data-item="IV cannula 18G">IV cannula 18G</button>
          <button data-item="500 ml crystalloid">500 ml crystalloid</button>
        </div>
        <div class="menu-section" data-section="E"><b>Misc</b>
          <button data-item="Warm blanket">Warm blanket</button>
          <button data-item="Glucose gel">Glucose gel</button>
        </div>
      </div>
      <div style="margin-top:6px; font-size:11px; opacity:0.8;">Click items to queue. Walk to patient to apply.</div>
    `;
    const trolleyMenu = new CSS2DObject(menuDiv); trolleyMenu.position.set(0, 1.12, 0); trolley.add(trolleyMenu);
    function showMenu(){ trolleyMenu.visible = true; menuDiv.style.display = 'block'; labelRenderer.domElement.style.pointerEvents = 'auto'; }
    function hideMenu(){ trolleyMenu.visible = false; menuDiv.style.display = 'none'; labelRenderer.domElement.style.pointerEvents = 'none'; }
    hideMenu();

    // Queue state
    let patientPlan = [];
    menuDiv.addEventListener('click', (e)=>{
      const b = e.target.closest('button'); if(!b) return; const item = b.dataset.item; const idx = patientPlan.indexOf(item);
      if (idx === -1) { patientPlan.push(item); b.classList.add('selected'); logEvent('pickup', { item }); }
      else { patientPlan.splice(idx, 1); b.classList.remove('selected'); logEvent('drop', { item }); }
      renderQueue();
    });

    // Applied label over patient
    const appliedDiv = document.createElement('div'); appliedDiv.className = 'applied'; appliedDiv.textContent = ''; appliedDiv.style.display = 'none';
    const appliedLabel = new CSS2DObject(appliedDiv); appliedLabel.position.set(0.5, 1.4, 0); bed.add(appliedLabel);

    // --- Physiology state (hidden) ---
    const phys = {
      bloodVol: 0.55,         // 1.0 is normal circulating volume (hypovolemic start)
      SVR: 1.8,               // high resistance for shock
      contractility: 0.6,     // moderate inotropy
      airwayR: 2.2,           // initial moderate airway resistance
      lungC: 0.6,             // compliance reduced
      shunt: 0.25,            // some shunt (mild lung problem)
      metabolic: 1.1,         // slight stress
      catechol: 0.3,          // endogenous stress
      sedation: 0.0,
      fatigue: 0.1,
      tempSet: 38.2,          // mild fever
      o2Device: 'air',        // current device state
      bronchoLevel: 0.0,
      epiLevel: 0.0,
      fluidPool: 0.0
    };

    // --- Displayed vitals with measurement lag ---
    const vitals = { rr: 36, spo2: 90, onO2: false, hr: 92, sbp: 56, dbp: 32, temp: 38.2, avpu: 'U', mapEst: 40 };

    // --- Mechanisms for calculation ---
    const mech = { PaO2: 55, CO: 3.2, MAP: 50, SV: 40, FiO2: 0.21 };
    let spo2Lag = 0;   // seconds since FiO2 change
    let nibpTimer = 0; // seconds since last NIBP reading

    // --- Helper functions ---
    function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
    function lerp1(x, target, tau, dt) { return x + (target - x) * (1 - Math.exp(-dt / tau)); }
    function noisy(v, pct=0.01){ return v * (1 + (Math.random()*2-1)*pct); }
    function deviceFiO2(dev){
      if (dev === 'nr15') return 0.85;
      if (dev === 'bvm')  return 0.95;
      return 0.21;
    }
    function satFromPaO2(p,P50adj=0){
      // Hill-type curve, with temp/CO2 shifting P50
      const n = 2.7, baseP50 = 26.8, P50 = baseP50 * (1+P50adj);
      const pn = Math.pow(p,n), d = pn + Math.pow(P50,n);
      return clamp(100 * pn / d, 50, 100);
    }

    // Dynamics core
    function updatePhys(dt) {
      // Drug and intervention kinetics
      phys.bronchoLevel = lerp1(phys.bronchoLevel, 0, 240, dt); // salbutamol fades over 4 min
      phys.epiLevel     = lerp1(phys.epiLevel, 0, 900, dt);     // adrenaline fades over 15m
      phys.fluidPool    = lerp1(phys.fluidPool, 0, 1800, dt);   // fluids redistribute 30m

      // Derived mechanism modifiers
      const airwayR = clamp(phys.airwayR * (1-.5*phys.bronchoLevel)*(1-.1*phys.epiLevel),0.6,4);
      const lungC = clamp(phys.lungC+0.1*phys.bronchoLevel,0.3,1.2);
      const shunt = clamp(phys.shunt * (1-.15*phys.epiLevel),0.05,0.6);
      const preload = clamp(phys.bloodVol+phys.fluidPool/5000,0.3,1.3);
      const SVR = clamp(phys.SVR+0.6*phys.epiLevel,0.6,3.0);
      const inotropy = clamp(phys.contractility+0.5*phys.epiLevel,0.3,1.8);

      // CO2 and temp proxy for P50 shifting (simple: fever or high RR shifts dcurve right)   
      const P50adj = 0.01*(phys.tempSet-37) + 0.01*((vitals.rr > 36)? (vitals.rr-36)/12 : 0);

      // Ventilation index (0-1)
      const ventIdx = clamp(lungC/(lungC+airwayR), 0.05, 0.95);
      // FiO2 by device
      const FiO2 = deviceFiO2(phys.o2Device);
      mech.FiO2 = FiO2;
      vitals.onO2 = FiO2 > 0.21+1e-3;  // convenience

      // Alveolar oxygen proxy then PaO2 after shunt and (add VQ term)
      const PAO2proxy = 500*FiO2*ventIdx;
      const PaO2 = clamp((1-shunt)*PAO2proxy - 15, 30, 500);
      mech.PaO2 = PaO2;

      // Work of breathing > fatigue (drains RR/TV over time)
      const wob = clamp(airwayR/lungC, 0.5, 6);
      phys.fatigue = clamp(phys.fatigue + dt*(wob-1.0)*0.02, 0, 1);

      // RR target from drive, hypoxia, fatigue
      const rrTarget = clamp(18*phys.metabolic + 10*(PaO2<60 ? (60-PaO2)/30 : 0) - 8*phys.fatigue, 8, 48);

      // Stroke volume and cardiac output
      const SVml = clamp(70*preload*inotropy/(1+0.35*(SVR-1)), 20, 110);
      const baseHR = 70+30*phys.catechol+10*phys.epiLevel-15*phys.sedation+7*(phys.tempSet-37);
      // Soft-baroreflex
      let baro = clamp(0.4*(70-vitals.mapEst), -25, 25);
      if(baro > 0) baro = baro*0.6+5*Math.tanh(baro/12); // ceiling to avoid runaway tachy
      if(baro < 0) baro = baro*0.5-2*Math.tanh(baro/8);  // floor so brady shows at high MAP
      const hrTarget = clamp(baseHR + baro, 40, 160);
      const COlpm = clamp((hrTarget*SVml)/1000, 2.0, 9.0);
      const MAP = clamp(45+18*COlpm*SVR, 35, 110);

      // SpO2 via dissociation, with lag, and curve shifting
      const spo2Target = satFromPaO2(PaO2, P50adj);
      if (Math.abs(spo2Target-vitals.spo2)>0.5) spo2Lag+=dt;
      const spo2Tau = vitals.onO2 ? 8 : 15;
      const spo2Now = lerp1(vitals.spo2, noisy(spo2Target,0.01), spo2Tau, dt);
      const tempNow = lerp1(vitals.temp, phys.tempSet, 900, dt);

      // Pulse pressure: wider when contractility/SV is high, narrows if high SVR
      const pulsePressure = clamp(25+20*inotropy+0.12*SVml-10*SVR+5*phys.catechol,15,70);
      const sbpNow = clamp(MAP+pulsePressure*2/3,50,220);
      const dbpNow = clamp(MAP-pulsePressure*1/3,25,120);
      // CPP proxy for AVPU
      const cppProxy = MAP-10;
      const avpuNow = (cppProxy<55||spo2Now<85) ? 'U' :
        (cppProxy<65||spo2Now<88) ? 'P' :
        (cppProxy<70||spo2Now<90) ? 'V' : 'A';
      // Measurement lags
      vitals.hr  = lerp1(vitals.hr,  noisy(hrTarget,0.01), 2.0, dt);
      vitals.rr  = lerp1(vitals.rr,  noisy(rrTarget,0.02), 3.0, dt);
      vitals.spo2= lerp1(vitals.spo2, spo2Now, 1.0, dt);
      vitals.temp= tempNow;
      // NIBP reading lags
      nibpTimer += dt;
      const urgent = sbpNow < 80;
      if (nibpTimer > (urgent ? 10 : 60)) {
        vitals.sbp = noisy(sbpNow, 0.02);
        vitals.dbp = noisy(dbpNow, 0.02);
        vitals.mapEst = noisy(MAP, 0.02);
        nibpTimer = 0;
      } else {
        vitals.sbp = lerp1(vitals.sbp, sbpNow, 30, dt);
        vitals.dbp = lerp1(vitals.dbp, dbpNow, 30, dt);
        vitals.mapEst = lerp1(vitals.mapEst, MAP, 30, dt);
      }
      vitals.avpu = avpuNow;
    }

    // --- Item/Intervention Application ---
    function applyItemEffects(items) {
      items.forEach(item => {
        switch(item){
          case 'Oropharyngeal airway':
            phys.airwayR = clamp(phys.airwayR - 0.3, 0.6, 4.0);
            break;
          case 'Suction catheter':
            phys.shunt = clamp(phys.shunt - 0.03, 0.05, 0.6);
            break;
          case 'Bag valve mask':
            phys.o2Device = 'bvm';
            const oldC = phys.lungC;
            phys.lungC = clamp(phys.lungC + 0.15, 0.3, 1.2);
            setTimeout(()=>{ phys.o2Device = 'air'; phys.lungC = oldC; }, 60000);
            break;
          case 'Oxygen mask 15 L':
            phys.o2Device = 'nr15';
            break;
          case 'Nebuliser salbutamol':
            scheduleIntervention(() => phys.bronchoLevel = clamp(phys.bronchoLevel + 0.02,0,1), 1000, true, 'salb');
            phys.catechol = clamp(phys.catechol + 0.05, 0, 1.5);
            break;
          case 'IV cannula 18G':
            break; // future effect
          case '500 ml crystalloid':
            phys.fluidPool = clamp(phys.fluidPool + 500, 0, 3000);
            phys.bloodVol  = clamp(phys.bloodVol + 0.05, 0.2, 1.4);
            break;
          case 'Non invasive BP':
            nibpTimer = 1000; // force immediate reading
            break;
          case 'Glucose gel':
            phys.sedation = clamp(phys.sedation - 0.1, 0, 1);
            break;
          case 'Warm blanket':
            phys.tempSet = clamp(phys.tempSet - 0.5, 35.5, 37.0);
            break;
          case 'Adrenaline IM 1:1000':
            scheduleIntervention(() => phys.epiLevel = clamp(phys.epiLevel+0.02,0,1), 1000, true, 'epi');
            break;
        }
      });
    }

    function renderQueue(){
      kitChips.innerHTML = '';
      patientPlan.forEach(item => { const s = document.createElement('span'); s.className = 'chip'; s.textContent = item; kitChips.appendChild(s); });
      kitCountDiv.textContent = 'Kit: ' + patientPlan.length;
    }
    function addAppliedHistory(items){
      const row = document.createElement('div');
      row.textContent = new Date().toLocaleTimeString() + ' Applied: ' + items.join(', ');
      appliedList.prepend(row);
      while (appliedList.childElementCount > 5) appliedList.removeChild(appliedList.lastChild);
    }

    // Proximity helpers
    const PROX_MENU = 1.3;
    const PROX_APPLY = 1.4;
    function distXZ(a, b){ const dx = a.x - b.x, dz = a.z - b.z; return Math.hypot(dx, dz); }
    function shouldShowTrolleyMenu(){ return distXZ(avatar.position, trolley.position) < PROX_MENU; }

    let appliedTimeout = null;
    function applyPlanIfNear(){
      const d = distXZ(avatar.position, bed.position);
      if (patientPlan.length > 0 && d < PROX_APPLY) {
        const applied = patientPlan.slice();
        patientPlan.length = 0;
        renderQueue();
        applyItemEffects(applied);
        clampVitals();
        renderVitals();
        addAppliedHistory(applied);
        logEvent('apply', { items: applied });
        appliedDiv.textContent = 'Applied: ' + applied.join(', ');
        appliedDiv.style.display = 'block';
        if (appliedTimeout) clearTimeout(appliedTimeout);
        appliedTimeout = setTimeout(()=>{ appliedDiv.style.display = 'none'; }, 2000);
      }
    }

    // Simple walk cycle for nurse
    let prevPos = avatar.position.clone();
    let walkPhase = 0;
    function updateNurseAnimation(dt){
      const limbs = avatar.userData.limbs;
      if (!limbs) return;
      const d = avatar.position.distanceTo(prevPos);
      prevPos.copy(avatar.position);
      const speedNow = d / Math.max(1e-6, dt);
      const moving = Math.min(speedNow / 1.2, 1.0);
      walkPhase += speedNow * 4.0 * dt;

      const swing = Math.sin(walkPhase) * 0.6 * moving;
      const counter = Math.sin(walkPhase + Math.PI) * 0.6 * moving;

      limbs.shoulderL.rotation.x = swing * 0.6;
      limbs.shoulderR.rotation.x = counter * 0.6;
      limbs.hipL.rotation.x = -swing * 0.7;
      limbs.hipR.rotation.x = -counter * 0.7;

      limbs.torso.position.y = 1.05 + Math.sin(walkPhase * 2.0) * 0.02 * moving;
      avatar.rotation.z = Math.sin(walkPhase) * 0.03 * moving;
      limbs.head.rotation.set(0, 0, 0);
    }

    // Animate
    let last = performance.now();
    function animate(){
      const now = performance.now();
      const dt = Math.min(0.05, (now - last) / 1000);
      last = now;
      updatePhys(dt); // ADDED: Update physiology-vitals coupling
      t += dt;

      move(dt);
      moveNurse(dt);
      updateNurseAnimation(dt);
      if (followNurse) updateCameraFollow();

      if (shouldShowTrolleyMenu()) showMenu(); else hideMenu();
      applyPlanIfNear();

      processScheduler();

      renderer.render(scene, camera);
      labelRenderer.render(scene, camera);
      requestAnimationFrame(animate);
    }

    // Resize
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      labelRenderer.setSize(window.innerWidth, window.innerHeight);
    });

    // Start
    requestAnimationFrame(animate);

    // Intervention scheduler
    const interventionScheduler = [];
    function scheduleIntervention(fn, delayMs, repeat, tag) {
      const now = performance.now();
      interventionScheduler.push({ fn, time: now + delayMs, repeat, period: delayMs, tag });
    }
    function processScheduler() {
      const now = performance.now();
      for (let i = interventionScheduler.length-1; i >= 0; --i) {
        const s = interventionScheduler[i];
        if (now >= s.time) {
          s.fn();
          if (s.repeat) {
            s.time += s.period;
          } else {
            interventionScheduler.splice(i,1);
          }
        }
      }
    }
  </script>
</body>
</html>
