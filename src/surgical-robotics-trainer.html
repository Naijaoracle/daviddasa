<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="Robotic Surgery AI Simulator - Precision Training & Autonomous Control">
  <title>Surgical Robotics AI Trainer - David Dasa</title>
  <link rel="icon" type="image/svg+xml" href="/src/favicon-DD-monogram.svg">
  <link rel="stylesheet" href="styles.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/particles.js/2.0.0/particles.min.js"></script>
  <style>
    .sim-container {
      max-width: 1200px;
      margin: 1rem auto; /* Reduced margin */
      background: rgba(255,255,255,0.82);
      border-radius: 1rem;
      box-shadow: 0 6px 18px rgba(0,0,0,0.04);
      border: 1px solid rgba(0,0,0,0.06);
      padding: 1rem; /* Reduced padding */
      display: grid;
      grid-template-columns: 300px 1fr;
      gap: 1.5rem;
      height: calc(100vh - 100px); /* Adjusted height */
      min-height: 500px; /* Reduced min-height */
      overflow: hidden; /* Prevent container expansion */
    }

    .controls {
      display: flex;
      flex-direction: column;
      gap: 1rem; /* Reduced gap */
      border-right: 1px solid rgba(0,0,0,0.1);
      padding-right: 1rem;
      overflow-y: auto; /* Allow scrolling for controls */
      max-height: 100%;
    }

    .control-group h3 {
      font-size: 0.9rem;
      color: #092917;
      text-transform: uppercase;
      margin-bottom: 0.8rem;
      padding-bottom: 0.5rem;
      border-bottom: 1px solid rgba(0,0,0,0.1);
    }

    .btn {
      width: 100%;
      padding: 0.8rem;
      border: none;
      border-radius: 0.5rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
      margin-bottom: 0.5rem;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 0.5rem;
    }

    .btn-primary { background: #2ecc71; color: white; }
    .btn-primary:hover { background: #27ae60; }
    
    .btn-ai { background: #3498db; color: white; }
    .btn-ai:hover { background: #2980b9; }

    .btn-difficulty { 
      background: #9b59b6; 
      color: white; 
      font-size: 0.85rem;
      padding: 0.6rem;
    }
    .btn-difficulty:hover { background: #8e44ad; }
    .btn-difficulty.active { background: #7d3c98; }

    .btn.active {
      box-shadow: inset 0 3px 5px rgba(0,0,0,0.2);
      transform: translateY(1px);
    }

    .stats-panel {
      background: white;
      border-radius: 0.5rem;
      padding: 1rem;
      border: 1px solid #eee;
    }

    .stat-row {
      display: flex;
      justify-content: space-between;
      margin-bottom: 0.5rem;
      font-size: 0.9rem;
    }

    .score-val { font-weight: 700; color: #2ecc71; }
    .danger-val { font-weight: 700; color: #e74c3c; }
    .blood-val { font-weight: 700; color: #c0392b; }
    
    /* Results Modal */
    .modal-overlay {
      display: none;
      position: absolute;
      top: 0; left: 0; width: 100%; height: 100%;
      background: rgba(0,0,0,0.85);
      z-index: 100;
      align-items: center;
      justify-content: center;
      border-radius: 1rem;
    }
    
    .modal-content {
      background: white;
      padding: 2rem;
      border-radius: 1rem;
      text-align: center;
      max-width: 400px;
      width: 90%;
    }
    
    .result-title { font-size: 2rem; margin-bottom: 1rem; font-weight: 800; }
    .pass { color: #2ecc71; }
    .fail { color: #e74c3c; }
    
    .result-stat {
      display: flex; 
      justify-content: space-between;
      margin: 0.5rem 0;
      padding: 0.5rem;
      background: #f8f9fa;
      border-radius: 0.25rem;
    }
    
    .key-badge {
      background: #eee;
      padding: 0.2rem 0.4rem;
      border-radius: 0.25rem;
      font-family: monospace;
      font-weight: bold;
      border: 1px solid #ccc;
      font-size: 0.8rem;
    }

    .canvas-wrapper {
      position: relative;
      background: #1a1a1a;
      border-radius: 1rem;
      overflow: hidden;
      cursor: crosshair;
    }

    #surgery-canvas {
      width: 100%;
      height: 100%;
      display: block;
    }

    .status-overlay {
      position: absolute;
      top: 1rem;
      left: 1rem;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 0.5rem 1rem;
      border-radius: 2rem;
      font-size: 0.85rem;
      pointer-events: none;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .status-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: #e74c3c;
    }
    .status-dot.active { background: #2ecc71; box-shadow: 0 0 8px #2ecc71; }

    /* Toggle Switch */
    .toggle-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 0.5rem;
    }
    
    .switch {
      position: relative;
      display: inline-block;
      width: 40px;
      height: 20px;
    }
    .switch input { opacity: 0; width: 0; height: 0; }
    .slider {
      position: absolute;
      cursor: pointer;
      top: 0; left: 0; right: 0; bottom: 0;
      background-color: #ccc;
      transition: .4s;
      border-radius: 20px;
    }
    .slider:before {
      position: absolute;
      content: "";
      height: 16px;
      width: 16px;
      left: 2px;
      bottom: 2px;
      background-color: white;
      transition: .4s;
      border-radius: 50%;
    }
    input:checked + .slider { background-color: #2ecc71; }
    input:checked + .slider:before { transform: translateX(20px); }

  </style>
</head>
<body>
  <nav>
    <ul>
      <li class="logo"><a href="https://www.daviddasa.com"><img src="https://github.com/Naijaoracle/daviddasa/blob/9556670c224c56b73e2a7f21ce1a4e27cbc1a90e/src/DD_logo.png?raw=true" alt="Logo" width="50" height="50"></a></li>
      <li class="home-link"><a href="https://www.daviddasa.com/">Home</a></li>
      <li><a href="https://www.daviddasa.com/projects">Projects</a></li>
    </ul>
  </nav>

  <!-- Particles Background -->
  <div id="particles-js"></div>

  <!-- Mobile Warning Overlay -->
  <div id="mobile-warning" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.95); z-index: 9999; align-items: center; justify-content: center; flex-direction: column; padding: 2rem; text-align: center; color: white;">
    <div style="font-size: 3rem; margin-bottom: 1rem;">üñ•Ô∏è</div>
    <h2 style="margin: 0 0 1rem 0;">Desktop Experience Required</h2>
    <p style="margin: 0 0 2rem 0; line-height: 1.6; max-width: 500px; color: #ccc;">
      This simulation relies on complex mouse tracking and keyboard inputs (WASD + Space) that are not available on touch devices.
    </p>
    <button onclick="document.getElementById('mobile-warning').style.display='none'" style="padding: 12px 24px; background: transparent; border: 1px solid rgba(255,255,255,0.5); color: white; border-radius: 6px; cursor: pointer; font-size: 1rem;">
      Dismiss (View Only)
    </button>
  </div>
  <style>
    @media (max-width: 1024px) {
      #mobile-warning { display: flex !important; }
      
      /* Layout adjustments in case user dismisses */
      .sim-container {
        grid-template-columns: 1fr;
        height: auto;
        min-height: 0;
      }
      .controls {
        border-right: none;
        border-bottom: 1px solid rgba(0,0,0,0.1);
        padding-right: 0;
        padding-bottom: 1rem;
        max-height: 400px;
      }
      .canvas-wrapper {
        height: 400px;
      }
    }
  </style>

  <div class="container">
    <div class="article-header" style="margin-top: 2rem;">
      <h1>ü§ñ Surgical Robotics AI Trainer</h1>
      <p>Demonstrating the synergy between robotic precision and AI safety. Control a virtual surgical arm with tremor filtration, or watch the AI perform autonomous tasks with perfect precision.</p>
      
      <div style="margin-top: 2rem; padding: 1.5rem; background: rgba(46, 204, 113, 0.1); border-left: 4px solid #2ecc71; border-radius: 0.5rem;">
        <h3 style="color: #092917; margin-top: 0; margin-bottom: 1rem;">üìö Related Datasets & Resources</h3>
        <p style="color: #4a4a4a; line-height: 1.7; margin-bottom: 1rem;">
          This demonstrator is inspired by real-world surgical robotics research. Explore these open datasets that enable AI-driven surgical tool detection, pose estimation, and action recognition:
        </p>
        <ul style="color: #4a4a4a; line-height: 1.8; margin: 0; padding-left: 1.5rem;">
          <li>
            <strong><a href="https://saras-mesad.grand-challenge.org/dataset/" target="_blank" rel="noopener" style="color: #2ecc71;">SARAS-MESAD Dataset</a></strong> ‚Äî Digital recordings from da Vinci Xi robotic system with 21 action classes (MESAD-Real) and 14 action classes (MESAD-Phantom) for prostatectomy procedures. Contains ~23K training images from real patient procedures and phantom training sessions.
          </li>
          <li>
            <strong><a href="https://surgpose.github.io/" target="_blank" rel="noopener" style="color: #2ecc71;">SurgPose Dataset</a></strong> ‚Äî ~120K surgical instrument instances (6 categories) with 7 semantic keypoints each, enabling 3D pose estimation and tracking for robotic surgical tools. Collected using UV-reactive paint for precise annotation.
          </li>
          <li>
            <strong><a href="https://github.com/luiscarlosgph/list-of-surgical-tool-datasets" target="_blank" rel="noopener" style="color: #2ecc71;">Surgical Tool Datasets Repository</a></strong> ‚Äî Comprehensive curated list of surgical tool datasets organized by task (tool classification, segmentation, action detection, skill assessment) including Cholec80, EndoVis, JIGSAWS, and more.
          </li>
        </ul>
      </div>
    </div>

    <div class="sim-container">
      <div class="controls">
        <div class="control-group">
          <h3>Mode Selection</h3>
          <button class="btn btn-primary active" id="btn-human" onclick="setMode('human')">üéÆ Human Control (Teleop)</button>
          <button class="btn btn-ai" id="btn-ai" onclick="setMode('ai')">üß† AI Autonomy Mode</button>
        </div>

        <div class="control-group">
          <h3>Difficulty Level</h3>
          <button class="btn btn-difficulty active" id="btn-easy" onclick="setDifficulty('easy')">üü¢ Easy</button>
          <button class="btn btn-difficulty" id="btn-medium" onclick="setDifficulty('medium')">üü° Medium</button>
          <button class="btn btn-difficulty" id="btn-hard" onclick="setDifficulty('hard')">üî¥ Hard</button>
        </div>

        <div class="control-group">
          <h3>Robotic Systems</h3>
          <div class="toggle-row">
            <label>Tremor Filtration</label>
            <label class="switch">
              <input type="checkbox" id="tremor-filter" checked>
              <span class="slider"></span>
            </label>
          </div>
          <div class="toggle-row">
            <label>Motion Scaling (3:1)</label>
            <label class="switch">
              <input type="checkbox" id="motion-scaling" checked>
              <span class="slider"></span>
            </label>
          </div>
        </div>

        <div class="control-group">
          <h3>AI Safety Monitor</h3>
          <div class="toggle-row">
            <label>Path Deviation Alert</label>
            <label class="switch">
              <input type="checkbox" id="path-alert" checked>
              <span class="slider"></span>
            </label>
          </div>
        </div>

        <div class="stats-panel">
          <div class="stat-row">
            <span>Precision Score:</span>
            <span class="score-val" id="score">100%</span>
          </div>
          <div class="stat-row">
            <span>Blood Loss:</span>
            <span class="blood-val" id="blood-loss">0 ml</span>
          </div>
          <div class="stat-row">
            <span>Progress:</span>
            <div style="width: 100px; background: #eee; height: 10px; border-radius: 5px; overflow: hidden;">
              <div id="progress-bar" style="width: 0%; height: 100%; background: #2ecc71; transition: width 0.2s;"></div>
            </div>
          </div>
          <div class="stat-row">
            <span>Time Elapsed:</span>
            <span id="timer">00:00</span>
          </div>
          <div class="stat-row">
            <span>Tremor Level:</span>
            <span id="tremor-val">Low</span>
          </div>
          <div class="stat-row">
            <span>Safety Violations:</span>
            <span class="danger-val" id="violations">0</span>
          </div>
        </div>
        
        <div style="margin-top: 1rem; font-size: 0.8rem; color: #666; background: #f8f9fa; padding: 1rem; border-radius: 0.5rem; border: 1px solid #eee; line-height: 1.8;">
          <strong>üè• Controls:</strong><br>
          <div style="display: flex; align-items: center; margin-bottom: 0.3rem;">
            <span class="key-badge" style="margin-right: 0.5rem;">Mouse</span> Move Surgical Arm
          </div>
          <div style="display: flex; align-items: center; margin-bottom: 0.3rem;">
            <span class="key-badge" style="margin-right: 0.5rem;">W</span>
            <span class="key-badge" style="margin-right: 0.5rem;">A</span>
            <span class="key-badge" style="margin-right: 0.5rem;">S</span>
            <span class="key-badge" style="margin-right: 0.5rem;">D</span> Move Coagulator
          </div>
          <div style="display: flex; align-items: center; margin-bottom: 0.3rem;">
            <span class="key-badge" style="margin-right: 0.5rem;">Space</span> Cauterize Bleeding
          </div>
          <div style="display: flex; align-items: center;">
            <span class="key-badge" style="margin-right: 0.5rem;">Enter</span> Finish Task
          </div>
        </div>

        <button class="btn" style="background:#95a5a6; color:white; margin-top: 1rem;" onclick="resetSim()">‚Ü∫ Reset Task</button>
      </div>

      <div class="canvas-wrapper" id="canvas-wrap">
        <div class="status-overlay">
          <div class="status-dot active" id="sys-status"></div>
          <span id="status-text">System Active: Master-Slave Engaged</span>
        </div>
        
        <!-- Results Modal -->
        <div class="modal-overlay" id="result-modal">
          <div class="modal-content">
            <div id="result-title" class="result-title">TASK COMPLETED</div>
            <p id="result-reason" style="margin-bottom: 1.5rem; color: #666; font-size: 1.1rem;">Assessment complete.</p>
            
            <div class="result-stat">
              <span>Final Precision:</span>
              <strong id="final-score">--</strong>
            </div>
            <div class="result-stat">
              <span>Blood Loss:</span>
              <strong id="final-blood">--</strong>
            </div>
            <div class="result-stat">
              <span>Time:</span>
              <strong id="final-time">--</strong>
            </div>
            <div style="margin-top: 1.5rem;">
              <button class="btn btn-primary" onclick="resetSim()">Start New Procedure</button>
            </div>
          </div>
        </div>

        <canvas id="surgery-canvas"></canvas>
      </div>
    </div>
  </div>

  <script>
    // Setup
    const canvas = document.getElementById('surgery-canvas');
    const ctx = canvas.getContext('2d');
    let width, height;
    
    // State
    let mouse = { x: 0, y: 0 };
    let robot = { x: 0, y: 0, targetX: 0, targetY: 0 };
    let hemoTool = { x: 100, y: 100, vx: 0, vy: 0 }; // Haemostasis Tool (WASD)
    let mode = 'human'; // 'human' or 'ai'
    let difficulty = 'easy'; 
    let path = [];
    let criticalStructures = []; // Array of {x, y, radius, bleeding, bleedIntensity}
    let score = 100;
    let violations = 0;
    let bloodLoss = 0;
    let startTime = 0;
    let elapsedTime = 0;
    let isGameActive = false;
    let keys = { w: false, a: false, s: false, d: false, space: false };
    
    // Animation
    let animationId;
    let particles = []; // Blood particles
    let sparks = []; // Cautery sparks
    
    // AI Autonomy State
    let aiProgress = 0;
    let aiSpeed = 2;
    
    // Path Tracking
    let checkpoints = []; // Indices of path points to visit
    let nextCheckpointIndex = 0;
    
    // Hard mode: Moving field
    let fieldOffset = { x: 0, y: 0 };
    let fieldVelocity = { x: 0.5, y: 0.3 };
    let time = 0; // Frame time for physics

    // Init
    function init() {
      resize();
      generatePath();
      generateCriticalStructures();
      
      robot.x = path[0].x;
      robot.y = path[0].y;
      robot.targetX = robot.x;
      robot.targetY = robot.y;
      
      // Reset Hemo Tool
      hemoTool.x = width - 100;
      hemoTool.y = height - 100;
      
      // Init Checkpoints (5 points: ~16%, 33%, 50%, 66%, 83%)
      checkpoints = [
        Math.floor(path.length * 0.16),
        Math.floor(path.length * 0.33),
        Math.floor(path.length * 0.50),
        Math.floor(path.length * 0.66),
        Math.floor(path.length * 0.83)
      ];
      nextCheckpointIndex = 0;
      
      fieldOffset = { x: 0, y: 0 };
      time = 0;
      
      resetGameStats();
      loop();
    }
    
    function resetGameStats() {
      score = 100;
      violations = 0;
      bloodLoss = 0;
      startTime = Date.now();
      isGameActive = true;
      particles = [];
      sparks = [];
      nextCheckpointIndex = 0; // Reset checkpoints progress
      document.getElementById('result-modal').style.display = 'none';
      document.getElementById('progress-bar').style.width = '0%';
      document.getElementById('progress-bar').style.background = '#2ecc71';
      
      // Reset Robot Position to Start
      if (path.length > 0) {
          robot.x = path[0].x;
          robot.y = path[0].y;
          robot.targetX = path[0].x;
          robot.targetY = path[0].y;
      }
      
      // Reset Hemo Tool
      hemoTool.x = width - 100;
      hemoTool.y = height - 100;
      
      if (mode === 'ai') aiProgress = 0;
    }

    function resize() {
      const wrap = document.getElementById('canvas-wrap');
      width = canvas.width = wrap.clientWidth;
      height = canvas.height = wrap.clientHeight;
      // Regenerate path and structures when resizing
      generatePath();
      generateCriticalStructures();
    }

    function generatePath() {
      // Create a curvy surgical path (Suture line)
      path = [];
      const points = 100;
      const amplitude = 60;
      const frequency = 0.02;
      const startX = 50;
      const endX = width - 50;
      const centerY = height / 2;

      for (let i = 0; i <= points; i++) {
        const x = startX + (endX - startX) * (i / points);
        const y = centerY + Math.sin(x * frequency) * amplitude;
        path.push({ x, y });
      }
    }

    function generateCriticalStructures() {
      criticalStructures = [];
      
      const createStructure = (x, y, r) => ({
        x, y, radius: r,
        bleeding: false,
        bleedIntensity: 0,
        bleedTimer: 0, // For clotting
        maxBleedTime: 300 + Math.random() * 200, // 5-8 seconds approx (at 60fps)
        isCauterized: false,
        poolSize: 0 // For blood pooling visual
      });
      
      if (difficulty === 'easy') {
        criticalStructures.push(createStructure(width / 2, height - 80, 60));
      } else if (difficulty === 'medium') {
        // Medium: Multiple blood vessels closer to the path
        const centerY = height / 2;
        const pathAmplitude = 60;
        
        // Generate 4-5 critical structures positioned near the path
        const numStructures = 5;
        for (let i = 0; i < numStructures; i++) {
          const t = (i + 1) / (numStructures + 1);
          const x = 50 + (width - 100) * t;
          const y = centerY + Math.sin(x * 0.02) * pathAmplitude;
          
          const offsetAngle = (i % 2 === 0 ? 1 : -1) * Math.PI / 2;
          const offsetDist = 40 + Math.random() * 30;
          
          criticalStructures.push(createStructure(
            x + Math.cos(offsetAngle) * offsetDist,
            y + Math.sin(offsetAngle) * offsetDist,
            35 + Math.random() * 15
          ));
        }
      } else if (difficulty === 'hard') {
        // Hard: More structures, even closer to path
        const centerY = height / 2;
        const pathAmplitude = 60;
        
        const numStructures = 7;
        for (let i = 0; i < numStructures; i++) {
          const t = (i + 1) / (numStructures + 1);
          const x = 50 + (width - 100) * t;
          const y = centerY + Math.sin(x * 0.02) * pathAmplitude;
          
          const offsetAngle = (i % 2 === 0 ? 1 : -1) * Math.PI / 2;
          const offsetDist = 25 + Math.random() * 20;
          
          criticalStructures.push(createStructure(
            x + Math.cos(offsetAngle) * offsetDist,
            y + Math.sin(offsetAngle) * offsetDist,
            30 + Math.random() * 20
          ));
        }
      }
    }

    // Main Loop
    function loop() {
      update();
      draw();
      animationId = requestAnimationFrame(loop);
    }

    function update() {
      if (!isGameActive) return;

      // 0. Hard mode: Update moving field
      if (difficulty === 'hard') {
        time += 0.02;
        // Create smooth circular/elliptical motion
        fieldOffset.x = Math.sin(time * 0.5) * 30;
        fieldOffset.y = Math.cos(time * 0.7) * 25;
      } else {
        fieldOffset = { x: 0, y: 0 };
      }
      
      // Hemo Tool Movement (WASD) or AI
      if (mode === 'human') {
          const hemoSpeed = 5;
          if (keys.w) hemoTool.y -= hemoSpeed;
          if (keys.s) hemoTool.y += hemoSpeed;
          if (keys.a) hemoTool.x -= hemoSpeed;
          if (keys.d) hemoTool.x += hemoSpeed;
          
          // Clamp Hemo Tool to screen
          hemoTool.x = Math.max(0, Math.min(width, hemoTool.x));
          hemoTool.y = Math.max(0, Math.min(height, hemoTool.y));
      } else {
          // AI Control for Hemo Tool
          // Find nearest bleeding, non-cauterized vessel
          let targetVessel = null;
          let minDist = Infinity;
          
          criticalStructures.forEach(crit => {
              if (crit.bleeding && !crit.isCauterized) {
                  const d = Math.hypot(crit.x + fieldOffset.x - hemoTool.x, crit.y + fieldOffset.y - hemoTool.y);
                  if (d < minDist) {
                      minDist = d;
                      targetVessel = crit;
                  }
              }
          });
          
          if (targetVessel) {
              const tx = targetVessel.x + fieldOffset.x;
              const ty = targetVessel.y + fieldOffset.y;
              
              // Move towards it
              const dx = tx - hemoTool.x;
              const dy = ty - hemoTool.y;
              const angle = Math.atan2(dy, dx);
              const speed = 6; // Slightly faster than human
              
              hemoTool.x += Math.cos(angle) * speed;
              hemoTool.y += Math.sin(angle) * speed;
              
              // Cauterize if close
              if (minDist < 20) {
                  keys.space = true;
              } else {
                  keys.space = false;
              }
          } else {
              // Park the tool if nothing to do
              keys.space = false;
              // Slowly return to rest position or hover near robot
              const dx = (robot.x + 50) - hemoTool.x;
              const dy = (robot.y + 50) - hemoTool.y;
              hemoTool.x += dx * 0.05;
              hemoTool.y += dy * 0.05;
          }
      }

      // 1. Input Handling (Human vs AI)
      if (mode === 'human') {
        let targetX = mouse.x;
        let targetY = mouse.y;

        // Motion Scaling (Precision Mode)
        if (document.getElementById('motion-scaling').checked) {
          // Only move robot 1/3rd of mouse distance relative to center
          // Simplified for demo: damped following
        }
        
        robot.targetX = targetX;
        robot.targetY = targetY;
      } else {
        // AI Mode: Follow path perfectly (accounting for field movement)
        if (aiProgress < path.length - 1) {
          const p1 = path[Math.floor(aiProgress)];
          const p2 = path[Math.floor(aiProgress) + 1];
          const t = aiProgress % 1;
          
          robot.targetX = p1.x + (p2.x - p1.x) * t + fieldOffset.x;
          robot.targetY = p1.y + (p2.y - p1.y) * t + fieldOffset.y;
          
          aiProgress += 0.02 * aiSpeed;
        } else {
           // AI finished
           finishGame();
        }
      }

      // 2. Robotics Physics (Smoothing / Tremor Filter)
      const smoothing = document.getElementById('tremor-filter').checked ? 0.08 : 0.3;
      
      // Lerp for damping
      robot.x += (robot.targetX - robot.x) * smoothing;
      robot.y += (robot.targetY - robot.y) * smoothing;
      
      // Update Time
      elapsedTime = Math.floor((Date.now() - startTime) / 1000);
      const mins = Math.floor(elapsedTime / 60).toString().padStart(2, '0');
      const secs = (elapsedTime % 60).toString().padStart(2, '0');
      document.getElementById('timer').textContent = `${mins}:${secs}`;

      // Calculate Progress & Checkpoints
      let closestIndex = 0;
      let minD = Infinity;
      path.forEach((p, i) => {
        const pd = Math.hypot((p.x + fieldOffset.x) - robot.x, (p.y + fieldOffset.y) - robot.y);
        if (pd < minD) { minD = pd; closestIndex = i; }
      });
      
      // Checkpoint Logic
      if (nextCheckpointIndex < checkpoints.length) {
        const targetIdx = checkpoints[nextCheckpointIndex];
        // If we are close to the checkpoint index AND physically close to the point
        // Allow some slack in index (e.g. +/- 5 points) to account for cutting corners slightly
        if (Math.abs(closestIndex - targetIdx) < 10 && minD < 40) {
            nextCheckpointIndex++;
        }
      }
      
      // Display Progress based on checkpoints to avoid jumping 0 -> 100
      // 4 segments: 0-25, 25-50, 50-75, 75-100
      // Base progress on passed checkpoints + proximity to next
      let basePct = nextCheckpointIndex * 20; // 5 checkpoints = 20% chunks
      
      const rawPct = Math.min(100, Math.round((closestIndex / (path.length - 1)) * 100));
      document.getElementById('progress-bar').style.width = rawPct + '%';
      
      // Color bar based on validity
      // If raw progress is significantly ahead of checkpoint progress (e.g. > 20%)
      if (rawPct > (nextCheckpointIndex + 1) * 20 + 5) {
          document.getElementById('progress-bar').style.background = '#f39c12'; // Warning color
      } else {
          document.getElementById('progress-bar').style.background = '#2ecc71';
      }

      // 3. Safety & Scoring
      checkSafety();
      
      // 4. Finish Condition (End of path)
      const lastP = path[path.length-1];
      const distToEnd = Math.hypot(robot.x - (lastP.x + fieldOffset.x), robot.y - (lastP.y + fieldOffset.y));
      if (distToEnd < 20) {
        finishGame();
      }
    }

    function checkSafety() {
      // Find distance to nearest path point (accounting for field movement)
      let minDist = Infinity;
      path.forEach(p => {
        const pathX = p.x + fieldOffset.x;
        const pathY = p.y + fieldOffset.y;
        const d = Math.hypot(pathX - robot.x, pathY - robot.y);
        if (d < minDist) minDist = d;
      });

      // Scoring (Precision)
      if (minDist > 20 && mode === 'human') {
        score -= 0.1;
        if(score < 0) score = 0;
        
        // Alert
        if(document.getElementById('path-alert').checked) {
            ctx.strokeStyle = 'rgba(231, 76, 60, 0.5)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(robot.x, robot.y, 30, 0, Math.PI*2);
            ctx.stroke();
        }
      }

      // Check all Critical Zones (blood vessels)
      criticalStructures.forEach(crit => {
        const critX = crit.x + fieldOffset.x;
        const critY = crit.y + fieldOffset.y;
        const distCrit = Math.hypot(robot.x - critX, robot.y - critY);
        
        // Collision Logic
        if (distCrit < crit.radius && !crit.isCauterized) {
          // Check if locked (Feature Removed, but collision still registers)
          // Original locking logic removed per request
          
          // CUT THE VESSEL -> BLEEDING
          if (!crit.bleeding) {
              violations += 0.05; // Only count initial cut as violation
              crit.bleeding = true;
              crit.bleedIntensity = crit.radius / 30; // Larger vessels bleed more
              crit.bleedTimer = 0;
              // Initial Burst
              for(let i=0; i<10; i++) {
                  particles.push(createBloodParticle(critX, critY, 4));
              }
          } else {
              // If already bleeding and we are still inside, maybe add more violations?
              // Or just leave it as is.
          }
        }
        
        // Haemostasis Logic (WASD Tool)
        const distHemo = Math.hypot(hemoTool.x - critX, hemoTool.y - critY);
        // Stricter cauterization radius (must be inside vessel)
        if (crit.bleeding && distHemo < crit.radius && keys.space) {
          crit.bleeding = false; // Cauterized
          crit.isCauterized = true;
          crit.bleedIntensity = 0;
          
          // Spark Effect
          for(let i=0; i<15; i++) {
            sparks.push({
                x: critX + (Math.random()-0.5)*20,
                y: critY + (Math.random()-0.5)*20,
                vx: (Math.random()-0.5)*5,
                vy: (Math.random()-0.5)*5,
                life: 1.0,
                color: '#f1c40f' // Gold/Yellow sparks
            });
          }
        }
        
        // Bleeding Effects
        if (crit.bleeding) {
          crit.bleedTimer++;
          // Auto-clotting logic
          if (crit.bleedTimer > crit.maxBleedTime) {
            crit.bleeding = false; // Clotted
            // Maybe allow it to re-bleed if cut again?
            // For now, it stops bleeding but isn't "cauterized" (so no points for fixing it, but blood loss stops)
          }
        
          bloodLoss += 0.2 * crit.bleedIntensity; 
          crit.poolSize = Math.min(crit.poolSize + 0.1, crit.radius * 1.5); // Pooling
          
          // Spawn particles
          if (Math.random() < 0.4 * crit.bleedIntensity) {
             particles.push(createBloodParticle(critX, critY, 2));
          }
        }
      });
      
      // Update Particles
      particles.forEach((p, i) => {
        p.x += p.vx;
        p.y += p.vy;
        p.life -= 0.02;
        if(p.life <= 0) particles.splice(i, 1);
      });
      
      // Update Sparks
      sparks.forEach((p, i) => {
        p.x += p.vx;
        p.y += p.vy;
        p.life -= 0.05; // Sparks die faster
        if(p.life <= 0) sparks.splice(i, 1);
      });

      // Update DOM
      document.getElementById('score').textContent = Math.round(score) + '%';
      document.getElementById('violations').textContent = Math.floor(violations);
      document.getElementById('blood-loss').textContent = Math.floor(bloodLoss) + ' ml';
      
      // Calculate Tremor
      const lag = Math.hypot(robot.targetX - robot.x, robot.targetY - robot.y);
      let tremorText = 'Low';
      if(lag > 50) tremorText = 'High';
      else if(lag > 20) tremorText = 'Medium';
      document.getElementById('tremor-val').textContent = tremorText;
    }
    
    function createBloodParticle(x, y, speedMult) {
        return {
           x: x + (Math.random() - 0.5) * 20,
           y: y + (Math.random() - 0.5) * 20,
           vx: (Math.random() - 0.5) * speedMult,
           vy: (Math.random() * speedMult) + 1, 
           life: 1.0,
           color: `rgba(192, 57, 43, ${0.5 + Math.random()*0.5})`
        };
    }

    function finishGame() {
      isGameActive = false;
      const modal = document.getElementById('result-modal');
      const title = document.getElementById('result-title');
      const reason = document.getElementById('result-reason');
      
      // Check for unresolved issues
      const activeBleeding = criticalStructures.filter(c => c.bleeding).length;
      const uncauterizedCuts = criticalStructures.filter(c => !c.isCauterized && c.bleedTimer > 0).length;
      const missedCheckpoints = checkpoints.length - nextCheckpointIndex;
      
      let passed = false;
      let failReason = "";
      
      if (missedCheckpoints > 0) {
          failReason = "FAILURE: Procedure incomplete. Path checkpoints skipped.";
      } else if (activeBleeding > 0) {
          failReason = "CRITICAL FAILURE: Patient left with active bleeding.";
      } else if (uncauterizedCuts > 0) {
          failReason = "FAILURE: Injured vessels were not properly cauterized.";
      } else if (bloodLoss >= 500) {
          failReason = "FAILURE: Excessive blood loss (>500ml).";
      } else if (score <= 70) {
          failReason = "FAILURE: Precision score below acceptable threshold (70%).";
      } else {
          passed = true;
      }
      
      if (passed) {
        title.textContent = "PROCEDURE SUCCESSFUL";
        title.className = "result-title pass";
        reason.textContent = "Excellent work. Hemostasis achieved and precision maintained.";
        reason.style.color = "#27ae60";
      } else {
        title.textContent = "PROCEDURE FAILED";
        title.className = "result-title fail";
        reason.textContent = failReason;
        reason.style.color = "#c0392b";
      }
      
      document.getElementById('final-score').textContent = Math.round(score) + '%';
      document.getElementById('final-score').style.color = score > 70 ? '#2ecc71' : '#e74c3c';
      
      document.getElementById('final-blood').textContent = Math.floor(bloodLoss) + ' ml';
      document.getElementById('final-blood').style.color = bloodLoss < 500 ? '#2ecc71' : '#e74c3c';
      
      document.getElementById('final-time').textContent = document.getElementById('timer').textContent;
      
      modal.style.display = 'flex';
    }

    function draw() {
      // Clear
      ctx.fillStyle = '#1a1a1a'; // Dark background
      ctx.fillRect(0, 0, width, height);

      // Draw Tissue / Background (with movement offset in hard mode)
      ctx.save();
      ctx.translate(fieldOffset.x, fieldOffset.y);
      
      ctx.fillStyle = '#2c2c2c';
      ctx.beginPath();
      ctx.arc(width/2, height/2, 300, 0, Math.PI*2);
      ctx.fill();

      // Draw all Critical Structures (Blood Vessels)
      criticalStructures.forEach((crit, index) => {
        // Draw Blood Pool (if any)
        if (crit.poolSize > 0) {
            ctx.fillStyle = 'rgba(150, 20, 20, 0.4)';
            ctx.beginPath();
            ctx.arc(crit.x, crit.y, crit.radius + crit.poolSize, 0, Math.PI*2);
            ctx.fill();
        }
      
        // Main Vessel Body
        if (crit.isCauterized) {
            // Charred / Cauterized Look
            ctx.fillStyle = '#555'; 
            ctx.strokeStyle = '#333';
        } else if (crit.bleeding) {
            // Bleeding Pulse
            ctx.fillStyle = `rgba(192, 57, 43, ${0.4 + Math.sin(Date.now()/200)*0.2})`;
            ctx.strokeStyle = '#c0392b';
        } else {
            // Normal
            ctx.fillStyle = 'rgba(231, 76, 60, 0.2)';
            ctx.strokeStyle = '#c0392b';
        }
        
        ctx.lineWidth = 2;
        ctx.setLineDash(crit.isCauterized ? [] : [5, 5]); // Solid line if cauterized
        ctx.beginPath();
        ctx.arc(crit.x, crit.y, crit.radius, 0, Math.PI*2);
        ctx.fill();
        ctx.stroke();
        ctx.setLineDash([]);
        
        // Label for first structure only
        if (index === 0 && criticalStructures.length === 1) {
          ctx.fillStyle = '#c0392b';
          ctx.font = '12px sans-serif';
          ctx.fillText('CRITICAL STRUCTURE (NO-FLY ZONE)', crit.x - 100, crit.y + crit.radius + 20);
        }
      });

      // Draw Particles (Blood)
      particles.forEach(p => {
        ctx.fillStyle = p.color;
        ctx.beginPath();
        ctx.arc(p.x, p.y, 3 * p.life, 0, Math.PI*2);
        ctx.fill();
      });
      
      // Draw Sparks
      sparks.forEach(p => {
        ctx.fillStyle = `rgba(241, 196, 15, ${p.life})`;
        ctx.beginPath();
        ctx.arc(p.x, p.y, 2, 0, Math.PI*2);
        ctx.fill();
      });

      // Draw Target Path (with movement offset)
      ctx.strokeStyle = 'rgba(46, 204, 113, 0.3)';
      ctx.lineWidth = 15; // Path width tolerance
      ctx.lineCap = 'round';
      ctx.beginPath();
      path.forEach((p, i) => {
        if (i === 0) ctx.moveTo(p.x, p.y);
        else ctx.lineTo(p.x, p.y);
      });
      ctx.stroke();

      // Draw Center Line
      ctx.strokeStyle = 'rgba(46, 204, 113, 0.8)';
      ctx.lineWidth = 2;
      ctx.stroke();
      
      // Checkpoints hidden to prevent gaming
      
      // Draw Start/End markers
      if(path.length > 0) {
         // Start
         ctx.fillStyle = '#2ecc71';
         ctx.beginPath(); ctx.arc(path[0].x, path[0].y, 5, 0, Math.PI*2); ctx.fill();
         ctx.fillText('START', path[0].x - 15, path[0].y - 15);
         
         // End
         ctx.fillStyle = '#e74c3c';
         ctx.beginPath(); ctx.arc(path[path.length-1].x, path[path.length-1].y, 5, 0, Math.PI*2); ctx.fill();
         ctx.fillText('FINISH', path[path.length-1].x - 15, path[path.length-1].y - 15);
      }
      
      ctx.restore(); // End of moving field context
      
      // --- Fixed Elements (Robot & Hemo Tool) ---
      
      // Draw Hemo Tool (WASD)
      ctx.shadowBlur = 10;
      ctx.shadowColor = 'rgba(241, 196, 15, 0.5)';
      ctx.strokeStyle = '#f1c40f'; // Yellow for cautery
      ctx.lineWidth = 2;
      
      // Crosshair shape
      const hx = hemoTool.x;
      const hy = hemoTool.y;
      ctx.beginPath();
      ctx.moveTo(hx - 10, hy); ctx.lineTo(hx + 10, hy);
      ctx.moveTo(hx, hy - 10); ctx.lineTo(hx, hy + 10);
      ctx.stroke();
      
      // Ring
      ctx.beginPath();
      ctx.arc(hx, hy, 15, 0, Math.PI*2);
      ctx.stroke();
      
      // Active State (Cauterizing)
      if (keys.space) {
        ctx.fillStyle = 'rgba(241, 196, 15, 0.5)';
        ctx.fill();
        ctx.shadowBlur = 20;
      }

      // Draw Robot Arm
      // Shadow
      ctx.shadowBlur = 15;
      ctx.shadowColor = 'rgba(52, 152, 219, 0.5)';
      
      // Tool Tip
      ctx.fillStyle = '#3498db'; // Robotic Blue
      ctx.beginPath();
      // Triangle shape for tool
      ctx.moveTo(robot.x, robot.y);
      ctx.lineTo(robot.x - 10, robot.y - 20);
      ctx.lineTo(robot.x + 10, robot.y - 20);
      ctx.closePath();
      ctx.fill();

      // Shaft (goes off screen)
      ctx.strokeStyle = '#7f8c8d'; // Metal
      ctx.lineWidth = 6;
      ctx.beginPath();
      ctx.moveTo(robot.x, robot.y - 20);
      ctx.lineTo(robot.x + (robot.x - width/2) * 0.1, -50); // Parallax effect
      ctx.stroke();
      
      ctx.shadowBlur = 0;

      // Mouse Target (Ghost cursor for human mode)
      if (mode === 'human') {
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.arc(mouse.x, mouse.y, 5, 0, Math.PI*2);
        ctx.stroke();
      }
    }

    // Interaction
    canvas.addEventListener('mousemove', e => {
      const rect = canvas.getBoundingClientRect();
      mouse.x = e.clientX - rect.left;
      mouse.y = e.clientY - rect.top;
    });

    function setMode(newMode) {
      mode = newMode;
      const btnHuman = document.getElementById('btn-human');
      const btnAi = document.getElementById('btn-ai');
      const statusText = document.getElementById('status-text');
      const sysStatus = document.getElementById('sys-status');

      if (mode === 'human') {
        btnHuman.classList.add('active');
        btnAi.classList.remove('active');
        statusText.textContent = "System Active: Master-Slave Engaged";
        sysStatus.classList.add('active');
        sysStatus.style.background = '#2ecc71';
        sysStatus.style.boxShadow = '0 0 8px #2ecc71';
        canvas.style.cursor = 'crosshair';
      } else {
        btnHuman.classList.remove('active');
        btnAi.classList.add('active');
        statusText.textContent = "AUTONOMOUS MODE: AI Control Active";
        sysStatus.classList.add('active');
        sysStatus.style.background = '#3498db';
        sysStatus.style.boxShadow = '0 0 8px #3498db';
        canvas.style.cursor = 'wait';
        
        // Reset AI position
        aiProgress = 0;
        robot.x = path[0].x;
        robot.y = path[0].y;
      }
      resetSim();
    }

    function setDifficulty(newDifficulty) {
      difficulty = newDifficulty;
      const btnEasy = document.getElementById('btn-easy');
      const btnMedium = document.getElementById('btn-medium');
      const btnHard = document.getElementById('btn-hard');
      
      // Update button states
      btnEasy.classList.remove('active');
      btnMedium.classList.remove('active');
      btnHard.classList.remove('active');
      
      if (difficulty === 'easy') {
        btnEasy.classList.add('active');
      } else if (difficulty === 'medium') {
        btnMedium.classList.add('active');
      } else if (difficulty === 'hard') {
        btnHard.classList.add('active');
      }
      
      // Regenerate critical structures and reset
      generateCriticalStructures();
      resetSim();
    }

    function resetSim() {
      resetGameStats();
    }

    // Particle Init
    window.addEventListener('load', () => {
      init();
      if (window.particlesJS) {
        particlesJS('particles-js', {
          particles: {
            number: { value: 60, density: { enable: true, value_area: 800 } },
            color: { value: '#2ecc71' },
            opacity: { value: 0.4, random: false },
            size: { value: 3, random: true },
            line_linked: { enable: true, distance: 150, color: '#2ecc71', opacity: 0.2 },
            move: { enable: true, speed: 1.5 }
          }
        });
      }
    });
    
    window.addEventListener('resize', resize);
    
    // Keyboard Controls
    window.addEventListener('keydown', e => {
      if(e.key === 'w' || e.key === 'W') keys.w = true;
      if(e.key === 'a' || e.key === 'A') keys.a = true;
      if(e.key === 's' || e.key === 'S') keys.s = true;
      if(e.key === 'd' || e.key === 'D') keys.d = true;
      if(e.key === ' ' || e.code === 'Space') keys.space = true;
      if(e.key === 'Enter') finishGame();
    });
    
    window.addEventListener('keyup', e => {
      if(e.key === 'w' || e.key === 'W') keys.w = false;
      if(e.key === 'a' || e.key === 'A') keys.a = false;
      if(e.key === 's' || e.key === 'S') keys.s = false;
      if(e.key === 'd' || e.key === 'D') keys.d = false;
      if(e.key === ' ' || e.code === 'Space') keys.space = false;
    });

  </script>

  <!-- Footer -->
  <footer>
    <p><strong>Disclaimer:</strong> This tool is for demonstration purposes only. It does not provide medical diagnosis, treatment, or clinical decision support. The simulation is a simplified model and should not be used for surgical training or clinical decision-making. Not intended for clinical use.</p>
    <p>&copy; 2025 David Dasa</p>
  </footer>
</body>
</html>
