<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <meta name="description" content="BP Prediction Visualizer - Interactive demonstration of blood pressure forecasting using lightweight models"/>
  <title>BP Prediction Visualizer - David Dasa</title>
  <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='64' height='64'%3E%3Ctext y='50' font-size='48'%3EDD%3C/text%3E%3C/svg%3E" type="image/svg+xml">

  <!-- All CSS is inline to keep this single-file -->
  <style>
    :root{
      --bg:#0b0c10; --panel:#101217; --muted:#7b8496; --ink:#e6e8ee;
      --accent:#7aa2ff; --accent2:#b58cff; --danger:#ff6b6b; --ok:#2dd4bf;
      --warn:#f59e0b; --grid:#1c2741; --card:#0c1428; --paper:#101a30;
      --light-text:#ffffff; --border:#1b2334;
    }
    *{box-sizing:border-box}
    body{
      margin:0; color:var(--ink);
      background: linear-gradient(180deg, #0b0c10 0%, #0b0c10 100%);
      font-family: Inter, system-ui, Segoe UI, Roboto, Arial, sans-serif;
      line-height: 1.6;
    }
    
    /* Navigation */
    nav ul{list-style:none; margin:0; padding:20px; display:flex; gap:24px; align-items:center; background:rgba(16,18,23,0.95); backdrop-filter:blur(10px); border-bottom:1px solid var(--border);}
    nav a{color:#cfe0ff; text-decoration:none; font-weight:500; transition:color 0.2s ease}
    nav a:hover{color:var(--accent)}
    nav .logo img{border-radius:12px; transition:transform 0.2s ease}
    nav .logo img:hover{transform:scale(1.05)}
    
    /* Container and layout */
    .container{max-width:1200px; margin:0 auto; padding:20px}
    .bp-container{background: linear-gradient(180deg, rgba(16,18,23,0.8), rgba(16,18,23,0.95)), radial-gradient(1200px 600px at 80% -20%, #15203a, transparent 60%); border-radius:24px; padding:32px; margin:32px 0; border:1px solid var(--border); box-shadow:0 20px 40px rgba(0,0,0,0.3);}
    .bp-header{text-align:center; margin-bottom:32px}
    .bp-header h1{margin:0 0 16px; font-size:3rem; color:var(--light-text); font-weight:700; letter-spacing:-0.02em}
    .bp-header p{margin:0; color:var(--muted); font-size:1.2rem}
    
    /* Grid layout */
    .wrap{display:grid; grid-template-columns:380px 1fr; gap:24px; padding:16px 0}
    .card{background:var(--panel); border:1px solid var(--border); border-radius:20px; box-shadow:0 8px 32px rgba(0,0,0,0.2); overflow:hidden}
    .left{padding:24px}
    .left h3{margin:0 0 16px; font-size:16px; color:var(--light-text); letter-spacing:0.02em; font-weight:600}
    
    /* Form elements */
    .row{display:flex; gap:12px; align-items:center; margin:16px 0; flex-wrap:wrap}
    label{font-size:13px; color:var(--muted); font-weight:500; margin-bottom:4px; display:block}
    input[type="number"], input[type="datetime-local"], input[type="text"]{
      width:100%; padding:12px 16px; border-radius:12px; background:rgba(12,20,38,0.8); color:var(--ink);
      border:1px solid rgba(26,38,68,0.6); outline:none; transition:all 0.2s ease; font-size:14px
    }
    input:focus{border-color:var(--accent); box-shadow:0 0 0 3px rgba(122,162,255,0.1)}
    
    /* Buttons */
    .btn{cursor:pointer; border:1px solid rgba(31,45,85,0.8); background:rgba(12,24,51,0.9); color:#d6e3ff; padding:12px 20px; border-radius:12px; font-size:14px; font-weight:500; transition:all 0.2s ease; border:1px solid rgba(31,45,85,0.8)}
    .btn:hover{background:rgba(15,32,71,0.95); transform:translateY(-1px); box-shadow:0 4px 12px rgba(0,0,0,0.2)}
    .btn.accent{border-color:var(--accent); background:rgba(10,28,70,0.9); color:var(--light-text)}
    .btn.accent:hover{background:rgba(10,28,70,1); box-shadow:0 4px 16px rgba(122,162,255,0.3)}
    
    /* Status pills */
    .pill{display:inline-flex; align-items:center; gap:8px; padding:8px 16px; border-radius:999px; font-size:13px; border:1px solid rgba(32,48,94,0.8); background:rgba(13,23,48,0.9); font-weight:500}
    .pill.ok{border-color:rgba(15,59,52,0.8); background:rgba(11,43,36,0.9); color:#b7ffef}
    .pill.warn{border-color:rgba(74,51,4,0.8); background:rgba(42,31,5,0.9); color:#ffd59e}
    .pill.danger{border-color:rgba(74,13,16,0.8); background:rgba(42,15,18,0.9); color:#ffb3b3}
    
    /* Grid and stats */
    .grid{display:grid; grid-template-columns:repeat(2,1fr); gap:16px}
    .stat{background:rgba(12,20,40,0.8); border:1px solid rgba(22,36,72,0.8); padding:16px; border-radius:16px; transition:transform 0.2s ease}
    .stat:hover{transform:translateY(-2px)}
    .stat .v{font-size:18px; font-weight:600; color:var(--light-text)}
    
    /* Toggles */
    .toggle{display:flex; align-items:center; gap:10px; font-size:14px; color:#cfe0ff; margin:12px 0; cursor:pointer}
    .toggle input{transform:translateY(1px); accent-color:var(--accent)}
    
    /* Chart area */
    .chartWrap{padding:20px}
    canvas{width:100%; height:420px; display:block; border-radius:12px}
    .legend{display:flex; gap:16px; padding:16px 20px; color:var(--muted); font-size:13px; flex-wrap:wrap; background:rgba(12,20,40,0.5); border-radius:12px; margin-top:16px}
    .dot{width:12px; height:12px; border-radius:4px; display:inline-block; margin-right:6px}
    .dashed{border-bottom:2px dashed var(--accent); width:20px; height:0; display:inline-block; transform:translateY(-3px)}
    
    /* Separators */
    .sep{height:1px; background:rgba(22,36,72,0.8); margin:20px 0; border-radius:1px}
    .subtitle{color:#93a6d8; font-size:12px; margin-top:-8px; font-style:italic}

    /* Project cards */
    .project-card{background:rgba(16,26,48,0.8); border:1px solid var(--border); border-radius:20px; padding:32px; margin:32px 0; box-shadow:0 8px 32px rgba(0,0,0,0.2)}
    .project-card h2{margin:0 0 16px; color:var(--light-text); font-size:1.8rem; font-weight:600}
    .project-card h3{margin:24px 0 12px; color:var(--light-text); font-size:1.3rem; font-weight:500}
    .project-item p{color:#d5e1ff; line-height:1.7; margin:16px 0; font-size:15px}
    .foot{color:#ffd59e; font-style:italic; margin-top:24px; padding-top:16px; border-top:1px solid rgba(22,36,72,0.5)}
    
    /* Footer */
    footer{padding:24px 20px; color:#9fb2e6; text-align:center; font-size:14px; background:rgba(16,18,23,0.95); border-top:1px solid var(--border)}

    /* Responsive design */
    @media (max-width: 860px){
      .wrap{grid-template-columns: 1fr; gap:20px}
      .bp-header h1{font-size:2.2rem}
      .bp-container{padding:24px; margin:24px 0}
      .left{padding:20px}
      .container{padding:16px}
    }
    
    @media (max-width: 480px){
      .bp-header h1{font-size:1.8rem}
      .bp-header p{font-size:1rem}
      .grid{grid-template-columns:1fr}
      .legend{flex-direction:column; gap:8px}
    }
  </style>
</head>
<body>
  <!-- Simple nav (links optional) -->
  <nav>
    <ul>
      <li class="logo"><a href="https://www.daviddasa.com"><img src="https://github.com/Naijaoracle/daviddasa/blob/9556670c224c56b73e2a7f21ce1a4e27cbc1a90e/src/DD_logo.png?raw=true" alt="Logo" width="42" height="42"></a></li>
      <li class="home-link"><a href="https://www.daviddasa.com/">Home</a></li>
      <li><a href="https://www.daviddasa.com/projects">Projects</a></li>
      <li><a href="https://www.daviddasa.com/contact">Contact</a></li>
    </ul>
  </nav>

  <div class="container">
    <main>
      <!-- BP Prediction Visualizer -->
      <section class="bp-container">
        <div class="bp-header">
          <h1>BP Prediction Visualizer</h1>
          <p>Interactive demonstration of 48-hour blood pressure forecasting (non-diagnostic)</p>
        </div>

        <div class="wrap">
          <!-- LEFT PANE -->
          <section class="card left">
            <h3>Data</h3>
            <div class="row" style="justify-content:space-between; flex-wrap:wrap; gap:10px">
              <button class="btn accent" id="loadSample">Load sample patient (14 days)</button>
              <small class="subtitle">All data stays in your browser. Uploads are disabled.</small>
            </div>

            <div class="sep"></div>
            <div class="grid">
              <div>
                <label>Generate synthetic (days)</label>
                <input id="days" type="number" min="3" max="60" value="14">
              </div>
              <div>
                <label>Noise σ (mmHg)</label>
                <input id="noise" type="number" min="1" max="12" value="4">
              </div>
            </div>
            <div class="grid" style="margin-top:6px">
              <div>
                <label>Sys base</label>
                <input id="sysBase" type="number" value="122">
              </div>
              <div>
                <label>Dia base</label>
                <input id="diaBase" type="number" value="78">
              </div>
            </div>
            <div class="row" style="margin-top:10px">
              <button class="btn" id="gen">Generate synthetic</button>
            </div>

            <div class="sep"></div>
            <h3>Forecast assumptions (next 48h)</h3>
            <label class="toggle"><input type="checkbox" id="missed"> Missed meds (≈ +8 mmHg for 24h)</label>
            <label class="toggle"><input type="checkbox" id="salt"> High salt (≈ +5 mmHg for 24h)</label>
            <label class="toggle"><input type="checkbox" id="stress"> Stress (≈ +6 mmHg for 12h)</label>

            <div class="sep"></div>
            <h3>Add reading &amp; recalibrate</h3>
            <div class="grid">
              <div><label>Time</label><input id="newTs" type="datetime-local"></div>
              <div><label>Sys / Dia</label><input id="newBP" type="text" placeholder="e.g. 128/82"></div>
            </div>
            <div class="row" style="margin-top:8px">
              <button class="btn" id="recal">Recalibrate</button>
              <small class="subtitle">Appends a reading and refits the models.</small>
            </div>

            <div class="sep"></div>
            <h3>Display</h3>
            <label class="toggle"><input type="checkbox" id="showARX" checked> Show ARX(1) forecast</label>
            <label class="toggle"><input type="checkbox" id="showGB" checked> Show GB-Stumps forecast</label>

            <div class="sep"></div>
            <div class="grid">
              <div class="stat">
                <label>MAE (last 72h) — Systolic</label>
                <div class="v" id="maeSys">–</div>
              </div>
              <div class="stat">
                <label>MAE (last 72h) — Diastolic</label>
                <div class="v" id="maeDia">–</div>
              </div>
            </div>
            <div class="row" style="margin-top:10px">
              <div id="confPill" class="pill">Confidence: –</div>
            </div>
          </section>

          <!-- RIGHT PANE -->
          <section class="card">
            <div class="chartWrap">
              <canvas id="chart" width="1200" height="460"></canvas>
              <div class="legend">
                <span><span class="dot" style="background:#6ee7ff"></span> Actual Sys</span>
                <span><span class="dot" style="background:#94ffa4"></span> Actual Dia</span>
                <span><span class="dot" style="background:var(--accent)"></span> ARX Sys <span class="dashed"></span></span>
                <span><span class="dot" style="background:#9aa0ff"></span> ARX Dia <span class="dashed"></span></span>
                <span><span class="dot" style="background:#ffc46b"></span> GB Sys <span class="dashed"></span></span>
                <span><span class="dot" style="background:#ff9ad4"></span> GB Dia <span class="dashed"></span></span>
                <span>Shaded = 95% CI</span>
              </div>
            </div>
          </section>
        </div>
      </section>

      <!-- Humanised write-up -->
      <section class="project-card">
        <h2>About this demo</h2>
        <div class="project-item">
          <p>
            This page is a working sketch of an idea: if we have a few days of recent blood-pressure readings,
            can a small, transparent model say something sensible about the next forty-eight hours? The
            answer here is “sometimes”—and that’s deliberate. You’ll see the familiar daily rhythm:
            lower values while sleeping, a rise after waking, and small wobbles across the day. The
            forecast traces that rhythm forward and adds a shaded band to show uncertainty. When the band
            is wide, we’re telling you the model is unsure.
          </p>

          <p>
            Two simple baselines sit under the hood. The first is an
            <em>ARX(1)</em> model that remembers yesterday’s level and adjusts for the time of day—think
            “short memory plus a day/night heartbeat.” The second is a tiny gradient-boosted model that
            learns a few bends and kinks in the curve from recent history. Neither is meant to be a final
            word; they’re here because their assumptions are easy to see, easy to question, and easy to
            improve.
          </p>

          <p>
            Real life doesn’t stay tidy, so the toggles let you play director: miss a dose, have a salty meal,
            or go through a stressful patch and watch the short-term forecast bump upward. If you take a new
            reading, use “recalibrate” and the models will fold it in; you’ll often see the uncertainty band
            tighten afterwards. The small tiles on the left report a recent error metric (MAE) and a plain-English
            confidence badge. High error or sparse data will push confidence down, as it should.
          </p>

          <p class="foot"><strong>Important:</strong> this is a research demonstrator. It is not a medical device,
            and it shouldn’t be used to diagnose, treat, or change medications. Any real deployment would need
            calibration to approved cuffs, larger and more diverse datasets, careful handling of medications and
            illness, and clinical oversight.</p>
        </div>
      </section>

      <section class="project-card">
        <h2>How a production system would go further</h2>
        <div class="project-item">
          <p>
            A practical system would weave in more context—wearable activity and sleep, medication timing,
            travel and shift-work patterns—and personalise the model to you over time. It would favour
            uncertainty-aware forecasts, show clear <em>“no forecast”</em> states when the signal is poor,
            and surface gentle, actionable prompts like “take a reading this evening.” Most importantly,
            it would continuously evaluate fairness and accuracy across age, sex, ethnicity, and device types,
            with privacy-preserving data practices by default.
          </p>
        </div>
      </section>
    </main>
  </div>

  <footer>
    <p>&copy; 2025 David Dasa • Non-diagnostic educational tool</p>
  </footer>

  <!-- All JS inline to keep this single-file -->
  <script>
  /* ------------------------------ Utilities ------------------------------ */
  const HOUR = 3600*1000;
  const clamp=(x,a,b)=>Math.max(a,Math.min(b,x));
  const mean = arr => arr.length?arr.reduce((a,b)=>a+b,0)/arr.length:0;
  const std = arr => { if(!arr.length) return 0; const m=mean(arr); return Math.sqrt(mean(arr.map(v=>(v-m)**2))); };
  const linspace=(a,b,n)=>Array.from({length:n},(_,i)=>a+(b-a)*(i/(n-1)));
  const lerp=(a,b,t)=>a+(b-a)*t;

  /* Simple seeded RNG for reproducible sample data */
  function rng(seed=123456789){ let x=seed>>>0; return ()=>{ x^=x<<13; x^=x>>>17; x^=x<<5; return (x>>>0)/4294967296; }; }

  /* Resample to hourly grid via linear interpolation */
  function toHourly(data){
    if(data.length<2) return [];
    const t0 = new Date(Math.ceil(data[0].t.getTime()/HOUR)*HOUR);
    const t1 = new Date(Math.floor(data[data.length-1].t.getTime()/HOUR)*HOUR);
    const hours = Math.round((t1-t0)/HOUR)+1;
    const grid = [];
    let j=0;
    for(let k=0;k<hours;k++){
      const tk = new Date(t0.getTime()+k*HOUR);
      while(j+1<data.length && data[j+1].t<=tk) j++;
      const a = data[j], b = data[Math.min(j+1,data.length-1)];
      const tA = a.t.getTime(), tB = b.t.getTime();
      let w = (tk.getTime()-tA)/Math.max(1,(tB-tA)); w = clamp(w,0,1);
      const sys = lerp(a.sys,b.sys,w);
      const dia = lerp(a.dia,b.dia,w);
      grid.push({t:tk, sys, dia});
    }
    return grid;
  }

  /* Circadian function: offset given hour (0-23). Positive during day, negative at night */
  function circadian(hour){
    const a = Math.sin((hour-7)/24*2*Math.PI)*4;
    const b = Math.sin((hour-19)/24*2*Math.PI)*2;
    return a + b;
  }

  /* Fixed, reproducible sample patient (hourly, 14 days) with planned events */
  function buildSamplePatient(days=14){
    const end = new Date(Math.floor(Date.now()/HOUR)*HOUR);
    const start = new Date(end.getTime()-days*24*HOUR);
    const r = rng(42);
    const baseSys = 124, baseDia = 79, noise = 3.5;

    // Planned events to make the story visible
    const events = [
      {t: new Date(start.getTime()+4*24*HOUR + 8*HOUR),  type:"missed"}, // day 5 morning
      {t: new Date(start.getTime()+9*24*HOUR + 19*HOUR), type:"salt"},   // day 10 evening
      {t: new Date(start.getTime()+12*24*HOUR+12*HOUR),  type:"stress"}  // day 13 midday
    ];

    const out=[];
    for(let t=start.getTime(); t<=end.getTime(); t+=HOUR){
      const d = new Date(t);
      const h = d.getHours();
      const circ = circadian(h);
      const has = (name, span) => events.some(e=> e.type===name && Math.abs(t - e.t.getTime()) <= span);

      const missed = has("missed", 24*HOUR);
      const salt   = has("salt",   24*HOUR);
      const stress = has("stress", 12*HOUR);

      const addSys = (missed?8:0) + (salt?5:0) + (stress?6:0);
      const addDia = (missed?5:0) + (salt?3:0) + (stress?4:0);

      const epsS = (r()*2-1)*noise;
      const epsD = (r()*2-1)*Math.max(2,noise*0.8);

      const sys = baseSys + circ + addSys + epsS;
      const dia = baseDia + circ*0.6 + addDia + epsD;

      out.push({t:new Date(t), sys, dia});
    }
    return out;
  }

  /* Also keep a synthetic generator for variation */
  function genSynthetic(days=14, sysBase=122, diaBase=78, noise=4){
    const end = new Date(Math.floor(Date.now()/HOUR)*HOUR);
    const start = new Date(end.getTime()-days*24*HOUR);
    const out=[];
    const r = rng(7);
    const randomEventTimes = [];
    const nEvents = Math.max(1, Math.round(days/5));
    for(let i=0;i<nEvents;i++){
      const t = new Date(start.getTime()+r()*(end-start));
      const type = ["missed","salt","stress"][Math.floor(r()*3)];
      randomEventTimes.push({t, type});
    }
    for(let t=start.getTime(); t<=end.getTime(); t+=HOUR){
      const d = new Date(t), h=d.getHours(), circ=circadian(h);
      const has=(name,span)=>randomEventTimes.some(e=> e.type===name && Math.abs(t - e.t.getTime()) <= span);
      const addSys = (has("missed",24*HOUR)?8:0) + (has("salt",24*HOUR)?5:0) + (has("stress",12*HOUR)?6:0);
      const addDia = (has("missed",24*HOUR)?5:0) + (has("salt",24*HOUR)?3:0) + (has("stress",12*HOUR)?4:0);
      const epsS = (r()*2-1)*noise;
      const epsD = (r()*2-1)*Math.max(2,noise*0.8);
      out.push({t:new Date(t), sys: sysBase + circ + addSys + epsS, dia: diaBase + circ*0.6 + addDia + epsD});
    }
    return out;
  }

  /* Feature builder for ML */
  function featuresAt(t, prev, knobs){
    const d = new Date(t);
    const hour = d.getHours(), dow = d.getDay();
    const isNight = (hour<7 || hour>=22)?1:0;
    const circ = circadian(hour);
    const dt = (t - NOW)/HOUR;
    const effMiss = knobs.missed && dt>=0 && dt<24 ? 1:0;
    const effSalt = knobs.salt && dt>=0 && dt<24 ? 1:0;
    const effStress = knobs.stress && dt>=0 && dt<12 ? 1:0;
    return {hour, dow, isNight, circ, prev, effMiss, effSalt, effStress};
  }

  /* ------------------------------ Models ------------------------------ */
  function fitARX(series){ // series: [{t, y}]
    if(series.length<3) return null;
    const X=[], Y=[];
    for(let i=1;i<series.length;i++){
      const ytm1 = series[i-1].y;
      const circ = circadian(series[i].t.getHours());
      X.push([1, ytm1, circ]);
      Y.push(series[i].y);
    }
    const XT = numericTranspose(X);
    const XTX = numericMatMul(XT,X);
    const XTY = numericVecMul(XT,Y);
    const beta = solve3x3(XTX,XTY); // [c, phi, gamma]
    const resid = [];
    for(let i=1;i<series.length;i++){
      const circ = circadian(series[i].t.getHours());
      const pred = beta[0] + beta[1]*series[i-1].y + beta[2]*circ;
      resid.push(series[i].y - pred);
    }
    const sigma2 = mean(resid.map(r=>r*r)) || 25;
    return {c:beta[0], phi:beta[1], gamma:beta[2], sigma2};
  }
  function forecastARX(model, lastY, horizonHours, knobs){
    if(!model) return {path:[], ci:[]};
    const out=[], ci=[];
    let y = lastY;
    for(let k=1;k<=horizonHours;k++){
      const t = new Date(NOW + k*HOUR);
      const circ = circadian(t.getHours());
      const bias = (knobs.missed && k<=24?8:0) + (knobs.salt && k<=24?5:0) + (knobs.stress && k<=12?6:0);
      y = model.c + model.phi*y + model.gamma*circ + bias;
      out.push({t, y});
      const var_k = model.sigma2 * (1 + Math.max(0,1-model.phi**(2*k)) / (1-model.phi**2 + 1e-6));
      const sd = Math.sqrt(var_k);
      ci.push({lo:y-1.96*sd, hi:y+1.96*sd});
    }
    return {path:out, ci};
  }

  /* Tiny Gradient Boosted Decision Stumps */
  function fitGBStumps(series){
    if(series.length<5) return null;
    const knobsZero = {missed:0,salt:0,stress:0};
    const X=[], y=[];
    for(let i=1;i<series.length;i++){
      const prev = series[i-1].y;
      const f = featuresAt(series[i].t, prev, knobsZero);
      X.push(f); y.push(series[i].y);
    }
    const M = 12;
    let pred = new Array(y.length).fill(mean(y));
    const trees=[];
    for(let m=0;m<M;m++){
      const residual = y.map((yi,i)=> yi - pred[i]);
      const cands = [
        ["prev", v=>v.prev, linspace(90,160,20)],
        ["circ", v=>v.circ, linspace(-6,6,16)],
        ["hour", v=>v.hour, [5,7,12,18,22]],
        ["isNight", v=>v.isNight, [0.5]],
        ["dow", v=>v.dow, [0.5,2.5,4.5]],
      ];
      let bestFeat=null, bestThr=0, bestGain=-Infinity, bestLeft={mu:0,n:0}, bestRight={mu:0,n:0};
      for(const [name, getter, THR] of cands){
        for(const thr of THR){
          let sumL=0,nL=0,sumR=0,nR=0;
          for(let i=0;i<X.length;i++){
            if(getter(X[i])<=thr){ sumL+=residual[i]; nL++; }
            else { sumR+=residual[i]; nR++; }
          }
          if(nL===0||nR===0) continue;
          const muL=sumL/nL, muR=sumR/nR;
          let gain=0;
          for(let i=0;i<X.length;i++){
            const mu = (getter(X[i])<=thr)?muL:muR;
            gain += (residual[i]**2) - ((residual[i]-mu)**2);
          }
          if(gain>bestGain){
            bestGain=gain; bestFeat=[name, getter]; bestThr=thr; bestLeft={mu:muL,n:nL}; bestRight={mu:muR,n:nR};
          }
        }
      }
      const lr = 0.2;
      trees.push({feat:bestFeat[0], thr:bestThr, left:bestLeft.mu*lr, right:bestRight.mu*lr});
      for(let i=0;i<X.length;i++){
        const val = (bestFeat[1](X[i])<=bestThr)?bestLeft.mu*lr:bestRight.mu*lr;
        pred[i]+=val;
      }
    }
    const resid = y.map((yi,i)=> yi - pred[i]);
    const sigma = std(resid) || 6;
    const base = mean(y);
    return {trees, base, sigma};
  }
  function gbPredict(model, f){
    let y = model.base;
    for(const t of model.trees){
      const val = (f[t.feat] <= t.thr) ? t.left : t.right;
      y += val;
    }
    return y;
  }
  function forecastGB(model, lastY, horizonHours, knobs){
    if(!model) return {path:[],ci:[]};
    const out=[], ci=[];
    let prev = lastY;
    for(let k=1;k<=horizonHours;k++){
      const t = new Date(NOW + k*HOUR);
      const f = featuresAt(t, prev, knobs);
      let yk = gbPredict(model, f);
      yk += (knobs.missed && k<=24?7:0) + (knobs.salt && k<=24?4:0) + (knobs.stress && k<=12?5:0);
      out.push({t, y:yk});
      ci.push({lo:yk-1.96*model.sigma, hi:yk+1.96*model.sigma});
      prev = yk;
    }
    return {path:out, ci};
  }

  /* Tiny 3x3 linear algebra */
  function numericTranspose(A){ const m=A.length,n=A[0].length; const T=Array.from({length:n},()=>Array(m).fill(0)); for(let i=0;i<m;i++) for(let j=0;j<n;j++) T[j][i]=A[i][j]; return T; }
  function numericMatMul(A,B){ const m=A.length, n=B[0].length, k=B.length; const C=Array.from({length:m},()=>Array(n).fill(0)); for(let i=0;i<m;i++) for(let j=0;j<n;j++){ let s=0; for(let t=0;t<k;t++) s+=A[i][t]*B[t][j]; C[i][j]=s;} return C; }
  function numericVecMul(A,b){ const m=A.length, n=A[0].length; const x=Array(m).fill(0); for(let i=0;i<m;i++){ let s=0; for(let j=0;j<n;j++) s+=A[i][j]*b[j]; x[i]=s;} return x; }
  function solve3x3(M,b){
    const A=[M[0].slice(),M[1].slice(),M[2].slice()], y=b.slice();
    for(let i=0;i<3;i++){
      let p=i; for(let r=i+1;r<3;r++) if(Math.abs(A[r][i])>Math.abs(A[p][i])) p=r;
      if(p!==i){ [A[i],A[p]]=[A[p],A[i]]; [y[i],y[p]]=[y[p],y[i]]; }
      const div=A[i][i]||1e-6;
      for(let j=i;j<3;j++) A[i][j]/=div; y[i]/=div;
      for(let r=0;r<3;r++) if(r!==i){
        const f=A[r][i];
        for(let j=i;j<3;j++) A[r][j]-=f*A[i][j];
        y[r]-=f*y[i];
      }
    }
    return y;
  }

  /* ------------------------------ Drawing ------------------------------ */
  const canvas = document.getElementById('chart');
  const ctx = canvas.getContext('2d');

  function draw(data, arxSys, arxDia, gbSys, gbDia, showARX, showGB){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    const t0 = new Date(data[Math.max(0,data.length-24*14)].t);
    const t1 = new Date(NOW + 48*HOUR);
    const padL=50, padR=20, padT=20, padB=34;
    const W=canvas.width-padL-padR, H=canvas.height-padT-padB;

    const vals = [];
    for(const d of data){ vals.push(d.sys, d.dia); }
    const addF = arr => arr?.forEach(p=>vals.push(p.y));
    [arxSys, arxDia, gbSys, gbDia].forEach(addF);
    const yMin = Math.floor((Math.min(...vals)-10)/5)*5;
    const yMax = Math.ceil((Math.max(...vals)+10)/5)*5;

    const xScale = t => padL + ((t - t0) / (t1 - t0)) * W;
    const yScale = v => padT + (1 - (v - yMin)/(yMax - yMin)) * H;

    // grid
    ctx.strokeStyle=getCss("--grid"); ctx.lineWidth=1;
    for(let v=yMin; v<=yMax; v+=10){
      ctx.beginPath(); ctx.moveTo(padL, yScale(v)); ctx.lineTo(padL+W, yScale(v)); ctx.stroke();
      ctx.fillStyle="#8aa0d8"; ctx.font="11px ui-monospace,monospace"; ctx.fillText(v.toString(), 6, yScale(v)+3);
    }
    for(let d=new Date(t0.getTime()); d<=t1; d=new Date(d.getTime()+24*HOUR)){
      const x=xScale(d);
      ctx.strokeStyle="#1a294a"; ctx.beginPath(); ctx.moveTo(x, padT); ctx.lineTo(x, padT+H); ctx.stroke();
      ctx.fillStyle="#9fb2e6"; ctx.font="11px Inter,system-ui,sans-serif";
      const s=d.toLocaleDateString(undefined,{month:'short',day:'numeric'}); ctx.fillText(s, x-16, padT+H+18);
    }

    function line(points, color, width=2, dash=null){
      ctx.save(); if(dash) ctx.setLineDash(dash);
      ctx.beginPath();
      for(let i=0;i<points.length;i++){
        const p=points[i]; if(!isFinite(p.y)) continue;
        const x=xScale(p.t), y=yScale(p.y);
        if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
      }
      ctx.strokeStyle=color; ctx.lineWidth=width; ctx.stroke(); ctx.restore();
    }
    function band(points, ci, color){
      if(!points.length) return;
      ctx.save(); ctx.fillStyle=color; ctx.beginPath();
      for(let i=0;i<points.length;i++){ const x=xScale(points[i].t), y=yScale(ci[i].hi); if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y); }
      for(let i=points.length-1;i>=0;i--){ const x = xScale(points[i].t), y = yScale(ci[i].lo); ctx.lineTo(x,y); }
      ctx.closePath(); ctx.globalAlpha=0.18; ctx.fill(); ctx.restore();
    }

    const last14 = data.slice(-24*14);
    line(last14.map(d=>({t:d.t,y:d.sys})),"#6ee7ff",2);
    line(last14.map(d=>({t:d.t,y:d.dia})),"#94ffa4",2);

    if(showARX){
      if(arxSys?.length){ band(arxSys, arxSysCI, "#63b3ff"); line(arxSys,"#63b3ff",2,[6,6]); }
      if(arxDia?.length){ band(arxDia, arxDiaCI, "#9aa0ff"); line(arxDia,"#9aa0ff",2,[6,6]); }
    }
    if(showGB){
      if(gbSys?.length){ band(gbSys, gbSysCI, "#ffc46b"); line(gbSys,"#ffc46b",2,[6,6]); }
      if(gbDia?.length){ band(gbDia, gbDiaCI, "#ff9ad4"); line(gbDia,"#ff9ad4",2,[6,6]); }
    }

    ctx.fillStyle="#ffe08a"; ctx.fillRect(xScale(NOW)-1, padT, 2, H+6);
    ctx.fillStyle="#c7d2fe"; ctx.font="11px Inter,system-ui"; ctx.fillText("now", xScale(NOW)-10, padT+12);
  }
  function getCss(name){ return getComputedStyle(document.documentElement).getPropertyValue(name).trim(); }

  /* ------------------------------ MAE / Confidence ------------------------------ */
  function maeOneStep(modelSys, modelDia, seriesSys, seriesDia){
    const n = Math.min(72, seriesSys.length-2);
    if(n<=0) return {sys:NaN, dia:NaN};
    let errS=0, errD=0;
    for(let i=seriesSys.length-n; i<seriesSys.length; i++){
      const circ = circadian(seriesSys[i].t.getHours());
      const yhatS = modelSys ? modelSys.c + modelSys.phi*seriesSys[i-1].y + modelSys.gamma*circ : seriesSys[i-1].y;
      const yhatD = modelDia ? modelDia.c + modelDia.phi*seriesDia[i-1].y + modelDia.gamma*circ : seriesDia[i-1].y;
      errS += Math.abs(seriesSys[i].y - yhatS);
      errD += Math.abs(seriesDia[i].y - yhatD);
    }
    return {sys:errS/n, dia:errD/n};
  }
  function setConfidence(maeSys, maeDia, count){
    const pill = document.getElementById('confPill');
    const bad = (maeSys>10 || maeDia>8 || count<72);
    const warn = (!bad && (maeSys>7 || maeDia>6));
    pill.className="pill " + (bad?"danger":(warn?"warn":"ok"));
    pill.textContent = "Confidence: " + (bad?"Low":(warn?"Moderate":"OK"));
  }

  /* ------------------------------ App State ------------------------------ */
  let DATA = [];    // hourly [{t, sys, dia}]
  let NOW  = new Date(Math.floor(Date.now()/HOUR)*HOUR).getTime();

  let arxS=null, arxD=null, gbS=null, gbD=null;
  let arxSys=[], arxDia=[], gbSys=[], gbDia=[], arxSysCI=[], arxDiaCI=[], gbSysCI=[], gbDiaCI=[];

  function refitAndRedraw(){
    if(DATA.length<24*3){
      draw(DATA, [], [], [], [], getShow('showARX'), getShow('showGB'));
      document.getElementById('maeSys').textContent="–";
      document.getElementById('maeDia').textContent="–";
      setConfidence(99,99,DATA.length);
      return;
    }
    const seriesS = DATA.map(d=>({t:d.t,y:d.sys}));
    const seriesD = DATA.map(d=>({t:d.t,y:d.dia}));
    arxS = fitARX(seriesS);
    arxD = fitARX(seriesD);
    gbS  = fitGBStumps(seriesS);
    gbD  = fitGBStumps(seriesD);

    const knobs = {missed:getChk('missed'), salt:getChk('salt'), stress:getChk('stress')};
    const lastS = seriesS[seriesS.length-1].y;
    const lastD = seriesD[seriesD.length-1].y;

    const fAS = forecastARX(arxS, lastS, 48, knobs);
    const fAD = forecastARX(arxD, lastD, 48, knobs);
    arxSys=fAS.path; arxSysCI=fAS.ci; arxDia=fAD.path; arxDiaCI=fAD.ci;

    const fGS = forecastGB(gbS, lastS, 48, knobs);
    const fGD = forecastGB(gbD, lastD, 48, knobs);
    gbSys=fGS.path; gbSysCI=fGS.ci; gbDia=fGD.path; gbDiaCI=fGD.ci;

    const mae = maeOneStep(arxS, arxD, seriesS, seriesD);
    document.getElementById('maeSys').textContent = isFinite(mae.sys)? mae.sys.toFixed(1)+" mmHg":"–";
    document.getElementById('maeDia').textContent = isFinite(mae.dia)? mae.dia.toFixed(1)+" mmHg":"–";
    setConfidence(mae.sys, mae.dia, DATA.length);

    draw(DATA, arxSys, arxDia, gbSys, gbDia, getShow('showARX'), getShow('showGB'));
  }

  /* ------------------------------ Events / UI ------------------------------ */
  function getVal(id){ return document.getElementById(id).value; }
  function getChk(id){ return document.getElementById(id).checked; }
  function getShow(id){ return document.getElementById(id).checked; }

  document.getElementById('gen').addEventListener('click', ()=>{
    const days = parseInt(getVal('days')), noise = parseFloat(getVal('noise'));
    const sysBase = parseFloat(getVal('sysBase')), diaBase = parseFloat(getVal('diaBase'));
    DATA = genSynthetic(days, sysBase, diaBase, noise);
    NOW  = new Date(Math.floor(DATA[DATA.length-1].t.getTime()/HOUR)*HOUR).getTime();
    refitAndRedraw();
  });

  document.getElementById('loadSample').addEventListener('click', ()=>{
    DATA = buildSamplePatient(14);
    NOW  = new Date(Math.floor(DATA[DATA.length-1].t.getTime()/HOUR)*HOUR).getTime();
    refitAndRedraw();
  });

  ['missed','salt','stress','showARX','showGB'].forEach(id=>{
    document.getElementById(id).addEventListener('change',()=>refitAndRedraw());
  });

  document.getElementById('recal').addEventListener('click',()=>{
    const ts = getVal('newTs');
    const bp = getVal('newBP').trim();
    if(!ts || !bp || !bp.includes('/')){ alert('Provide time and BP as "123/78"'); return; }
    const [s,d] = bp.split('/').map(x=>parseFloat(x));
    if(!isFinite(s)||!isFinite(d)){ alert('Invalid numbers.'); return; }
    const t = new Date(ts);
    DATA.push({t, sys:s, dia:d});
    DATA.sort((a,b)=>a.t-b.t);
    DATA = toHourly(DATA);
    NOW  = new Date(Math.floor(DATA[DATA.length-1].t.getTime()/HOUR)*HOUR).getTime();
    refitAndRedraw();
  });

  /* ------------------------------ Bootstrap ------------------------------ */
  // Start with the built-in sample patient so there’s data immediately.
  DATA = buildSamplePatient(14);
  NOW  = new Date(Math.floor(DATA[DATA.length-1].t.getTime()/HOUR)*HOUR).getTime();
  refitAndRedraw();

  </script>
</body>
</html>
